// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: myadmin.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_myadmin_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_myadmin_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_myadmin_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_myadmin_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_myadmin_2eproto;
namespace adminspace {
class AdminId;
struct AdminIdDefaultTypeInternal;
extern AdminIdDefaultTypeInternal _AdminId_default_instance_;
class AllItemList;
struct AllItemListDefaultTypeInternal;
extern AllItemListDefaultTypeInternal _AllItemList_default_instance_;
class AllOrderList;
struct AllOrderListDefaultTypeInternal;
extern AllOrderListDefaultTypeInternal _AllOrderList_default_instance_;
class AllStationList;
struct AllStationListDefaultTypeInternal;
extern AllStationListDefaultTypeInternal _AllStationList_default_instance_;
class BaseReply3;
struct BaseReply3DefaultTypeInternal;
extern BaseReply3DefaultTypeInternal _BaseReply3_default_instance_;
class ItemInfo;
struct ItemInfoDefaultTypeInternal;
extern ItemInfoDefaultTypeInternal _ItemInfo_default_instance_;
class OrderInfo;
struct OrderInfoDefaultTypeInternal;
extern OrderInfoDefaultTypeInternal _OrderInfo_default_instance_;
class StationInfo;
struct StationInfoDefaultTypeInternal;
extern StationInfoDefaultTypeInternal _StationInfo_default_instance_;
}  // namespace adminspace
PROTOBUF_NAMESPACE_OPEN
template<> ::adminspace::AdminId* Arena::CreateMaybeMessage<::adminspace::AdminId>(Arena*);
template<> ::adminspace::AllItemList* Arena::CreateMaybeMessage<::adminspace::AllItemList>(Arena*);
template<> ::adminspace::AllOrderList* Arena::CreateMaybeMessage<::adminspace::AllOrderList>(Arena*);
template<> ::adminspace::AllStationList* Arena::CreateMaybeMessage<::adminspace::AllStationList>(Arena*);
template<> ::adminspace::BaseReply3* Arena::CreateMaybeMessage<::adminspace::BaseReply3>(Arena*);
template<> ::adminspace::ItemInfo* Arena::CreateMaybeMessage<::adminspace::ItemInfo>(Arena*);
template<> ::adminspace::OrderInfo* Arena::CreateMaybeMessage<::adminspace::OrderInfo>(Arena*);
template<> ::adminspace::StationInfo* Arena::CreateMaybeMessage<::adminspace::StationInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace adminspace {

// ===================================================================

class AdminId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:adminspace.AdminId) */ {
 public:
  inline AdminId() : AdminId(nullptr) {}
  ~AdminId() override;
  explicit PROTOBUF_CONSTEXPR AdminId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AdminId(const AdminId& from);
  AdminId(AdminId&& from) noexcept
    : AdminId() {
    *this = ::std::move(from);
  }

  inline AdminId& operator=(const AdminId& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdminId& operator=(AdminId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AdminId& default_instance() {
    return *internal_default_instance();
  }
  static inline const AdminId* internal_default_instance() {
    return reinterpret_cast<const AdminId*>(
               &_AdminId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AdminId& a, AdminId& b) {
    a.Swap(&b);
  }
  inline void Swap(AdminId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdminId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AdminId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AdminId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AdminId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AdminId& from) {
    AdminId::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdminId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "adminspace.AdminId";
  }
  protected:
  explicit AdminId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdminIdFieldNumber = 1,
  };
  // string admin_id_ = 1;
  void clear_admin_id_();
  const std::string& admin_id_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_admin_id_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_admin_id_();
  PROTOBUF_NODISCARD std::string* release_admin_id_();
  void set_allocated_admin_id_(std::string* admin_id_);
  private:
  const std::string& _internal_admin_id_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_admin_id_(const std::string& value);
  std::string* _internal_mutable_admin_id_();
  public:

  // @@protoc_insertion_point(class_scope:adminspace.AdminId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr admin_id__;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myadmin_2eproto;
};
// -------------------------------------------------------------------

class ItemInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:adminspace.ItemInfo) */ {
 public:
  inline ItemInfo() : ItemInfo(nullptr) {}
  ~ItemInfo() override;
  explicit PROTOBUF_CONSTEXPR ItemInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ItemInfo(const ItemInfo& from);
  ItemInfo(ItemInfo&& from) noexcept
    : ItemInfo() {
    *this = ::std::move(from);
  }

  inline ItemInfo& operator=(const ItemInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemInfo& operator=(ItemInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemInfo* internal_default_instance() {
    return reinterpret_cast<const ItemInfo*>(
               &_ItemInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ItemInfo& a, ItemInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ItemInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ItemInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ItemInfo& from) {
    ItemInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "adminspace.ItemInfo";
  }
  protected:
  explicit ItemInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemIdFieldNumber = 1,
    kItemNameFieldNumber = 2,
    kItemPriceFieldNumber = 3,
    kItemDescriptionFieldNumber = 4,
    kAdminIdFieldNumber = 5,
  };
  // string item_id_ = 1;
  void clear_item_id_();
  const std::string& item_id_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_item_id_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_item_id_();
  PROTOBUF_NODISCARD std::string* release_item_id_();
  void set_allocated_item_id_(std::string* item_id_);
  private:
  const std::string& _internal_item_id_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item_id_(const std::string& value);
  std::string* _internal_mutable_item_id_();
  public:

  // string item_name_ = 2;
  void clear_item_name_();
  const std::string& item_name_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_item_name_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_item_name_();
  PROTOBUF_NODISCARD std::string* release_item_name_();
  void set_allocated_item_name_(std::string* item_name_);
  private:
  const std::string& _internal_item_name_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item_name_(const std::string& value);
  std::string* _internal_mutable_item_name_();
  public:

  // string item_price_ = 3;
  void clear_item_price_();
  const std::string& item_price_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_item_price_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_item_price_();
  PROTOBUF_NODISCARD std::string* release_item_price_();
  void set_allocated_item_price_(std::string* item_price_);
  private:
  const std::string& _internal_item_price_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item_price_(const std::string& value);
  std::string* _internal_mutable_item_price_();
  public:

  // string item_description_ = 4;
  void clear_item_description_();
  const std::string& item_description_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_item_description_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_item_description_();
  PROTOBUF_NODISCARD std::string* release_item_description_();
  void set_allocated_item_description_(std::string* item_description_);
  private:
  const std::string& _internal_item_description_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item_description_(const std::string& value);
  std::string* _internal_mutable_item_description_();
  public:

  // string admin_id_ = 5;
  void clear_admin_id_();
  const std::string& admin_id_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_admin_id_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_admin_id_();
  PROTOBUF_NODISCARD std::string* release_admin_id_();
  void set_allocated_admin_id_(std::string* admin_id_);
  private:
  const std::string& _internal_admin_id_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_admin_id_(const std::string& value);
  std::string* _internal_mutable_admin_id_();
  public:

  // @@protoc_insertion_point(class_scope:adminspace.ItemInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr item_id__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr item_name__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr item_price__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr item_description__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr admin_id__;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myadmin_2eproto;
};
// -------------------------------------------------------------------

class AllItemList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:adminspace.AllItemList) */ {
 public:
  inline AllItemList() : AllItemList(nullptr) {}
  ~AllItemList() override;
  explicit PROTOBUF_CONSTEXPR AllItemList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AllItemList(const AllItemList& from);
  AllItemList(AllItemList&& from) noexcept
    : AllItemList() {
    *this = ::std::move(from);
  }

  inline AllItemList& operator=(const AllItemList& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllItemList& operator=(AllItemList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AllItemList& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllItemList* internal_default_instance() {
    return reinterpret_cast<const AllItemList*>(
               &_AllItemList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AllItemList& a, AllItemList& b) {
    a.Swap(&b);
  }
  inline void Swap(AllItemList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllItemList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllItemList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AllItemList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AllItemList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AllItemList& from) {
    AllItemList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AllItemList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "adminspace.AllItemList";
  }
  protected:
  explicit AllItemList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemInfoFieldNumber = 3,
    kReturnMessageFieldNumber = 2,
    kReturnResultFieldNumber = 1,
  };
  // repeated .adminspace.ItemInfo item_info_ = 3;
  int item_info__size() const;
  private:
  int _internal_item_info__size() const;
  public:
  void clear_item_info_();
  ::adminspace::ItemInfo* mutable_item_info_(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::adminspace::ItemInfo >*
      mutable_item_info_();
  private:
  const ::adminspace::ItemInfo& _internal_item_info_(int index) const;
  ::adminspace::ItemInfo* _internal_add_item_info_();
  public:
  const ::adminspace::ItemInfo& item_info_(int index) const;
  ::adminspace::ItemInfo* add_item_info_();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::adminspace::ItemInfo >&
      item_info_() const;

  // string return_message_ = 2;
  void clear_return_message_();
  const std::string& return_message_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_return_message_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_return_message_();
  PROTOBUF_NODISCARD std::string* release_return_message_();
  void set_allocated_return_message_(std::string* return_message_);
  private:
  const std::string& _internal_return_message_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_return_message_(const std::string& value);
  std::string* _internal_mutable_return_message_();
  public:

  // bool return_result_ = 1;
  void clear_return_result_();
  bool return_result_() const;
  void set_return_result_(bool value);
  private:
  bool _internal_return_result_() const;
  void _internal_set_return_result_(bool value);
  public:

  // @@protoc_insertion_point(class_scope:adminspace.AllItemList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::adminspace::ItemInfo > item_info__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr return_message__;
    bool return_result__;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myadmin_2eproto;
};
// -------------------------------------------------------------------

class StationInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:adminspace.StationInfo) */ {
 public:
  inline StationInfo() : StationInfo(nullptr) {}
  ~StationInfo() override;
  explicit PROTOBUF_CONSTEXPR StationInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StationInfo(const StationInfo& from);
  StationInfo(StationInfo&& from) noexcept
    : StationInfo() {
    *this = ::std::move(from);
  }

  inline StationInfo& operator=(const StationInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline StationInfo& operator=(StationInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StationInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const StationInfo* internal_default_instance() {
    return reinterpret_cast<const StationInfo*>(
               &_StationInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(StationInfo& a, StationInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(StationInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StationInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StationInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StationInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StationInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StationInfo& from) {
    StationInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StationInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "adminspace.StationInfo";
  }
  protected:
  explicit StationInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStationIdFieldNumber = 1,
    kStationNameFieldNumber = 2,
    kStationPositionFieldNumber = 3,
    kStationDescriptionFieldNumber = 4,
    kAdminIdFieldNumber = 5,
  };
  // string station_id_ = 1;
  void clear_station_id_();
  const std::string& station_id_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_station_id_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_station_id_();
  PROTOBUF_NODISCARD std::string* release_station_id_();
  void set_allocated_station_id_(std::string* station_id_);
  private:
  const std::string& _internal_station_id_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_station_id_(const std::string& value);
  std::string* _internal_mutable_station_id_();
  public:

  // string station_name_ = 2;
  void clear_station_name_();
  const std::string& station_name_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_station_name_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_station_name_();
  PROTOBUF_NODISCARD std::string* release_station_name_();
  void set_allocated_station_name_(std::string* station_name_);
  private:
  const std::string& _internal_station_name_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_station_name_(const std::string& value);
  std::string* _internal_mutable_station_name_();
  public:

  // string station_position_ = 3;
  void clear_station_position_();
  const std::string& station_position_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_station_position_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_station_position_();
  PROTOBUF_NODISCARD std::string* release_station_position_();
  void set_allocated_station_position_(std::string* station_position_);
  private:
  const std::string& _internal_station_position_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_station_position_(const std::string& value);
  std::string* _internal_mutable_station_position_();
  public:

  // string station_description_ = 4;
  void clear_station_description_();
  const std::string& station_description_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_station_description_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_station_description_();
  PROTOBUF_NODISCARD std::string* release_station_description_();
  void set_allocated_station_description_(std::string* station_description_);
  private:
  const std::string& _internal_station_description_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_station_description_(const std::string& value);
  std::string* _internal_mutable_station_description_();
  public:

  // string admin_id_ = 5;
  void clear_admin_id_();
  const std::string& admin_id_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_admin_id_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_admin_id_();
  PROTOBUF_NODISCARD std::string* release_admin_id_();
  void set_allocated_admin_id_(std::string* admin_id_);
  private:
  const std::string& _internal_admin_id_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_admin_id_(const std::string& value);
  std::string* _internal_mutable_admin_id_();
  public:

  // @@protoc_insertion_point(class_scope:adminspace.StationInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr station_id__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr station_name__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr station_position__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr station_description__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr admin_id__;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myadmin_2eproto;
};
// -------------------------------------------------------------------

class AllStationList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:adminspace.AllStationList) */ {
 public:
  inline AllStationList() : AllStationList(nullptr) {}
  ~AllStationList() override;
  explicit PROTOBUF_CONSTEXPR AllStationList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AllStationList(const AllStationList& from);
  AllStationList(AllStationList&& from) noexcept
    : AllStationList() {
    *this = ::std::move(from);
  }

  inline AllStationList& operator=(const AllStationList& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllStationList& operator=(AllStationList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AllStationList& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllStationList* internal_default_instance() {
    return reinterpret_cast<const AllStationList*>(
               &_AllStationList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AllStationList& a, AllStationList& b) {
    a.Swap(&b);
  }
  inline void Swap(AllStationList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllStationList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllStationList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AllStationList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AllStationList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AllStationList& from) {
    AllStationList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AllStationList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "adminspace.AllStationList";
  }
  protected:
  explicit AllStationList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStationInfoFieldNumber = 3,
    kReturnMessageFieldNumber = 2,
    kReturnResultFieldNumber = 1,
  };
  // repeated .adminspace.StationInfo station_info_ = 3;
  int station_info__size() const;
  private:
  int _internal_station_info__size() const;
  public:
  void clear_station_info_();
  ::adminspace::StationInfo* mutable_station_info_(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::adminspace::StationInfo >*
      mutable_station_info_();
  private:
  const ::adminspace::StationInfo& _internal_station_info_(int index) const;
  ::adminspace::StationInfo* _internal_add_station_info_();
  public:
  const ::adminspace::StationInfo& station_info_(int index) const;
  ::adminspace::StationInfo* add_station_info_();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::adminspace::StationInfo >&
      station_info_() const;

  // string return_message_ = 2;
  void clear_return_message_();
  const std::string& return_message_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_return_message_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_return_message_();
  PROTOBUF_NODISCARD std::string* release_return_message_();
  void set_allocated_return_message_(std::string* return_message_);
  private:
  const std::string& _internal_return_message_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_return_message_(const std::string& value);
  std::string* _internal_mutable_return_message_();
  public:

  // bool return_result_ = 1;
  void clear_return_result_();
  bool return_result_() const;
  void set_return_result_(bool value);
  private:
  bool _internal_return_result_() const;
  void _internal_set_return_result_(bool value);
  public:

  // @@protoc_insertion_point(class_scope:adminspace.AllStationList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::adminspace::StationInfo > station_info__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr return_message__;
    bool return_result__;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myadmin_2eproto;
};
// -------------------------------------------------------------------

class OrderInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:adminspace.OrderInfo) */ {
 public:
  inline OrderInfo() : OrderInfo(nullptr) {}
  ~OrderInfo() override;
  explicit PROTOBUF_CONSTEXPR OrderInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderInfo(const OrderInfo& from);
  OrderInfo(OrderInfo&& from) noexcept
    : OrderInfo() {
    *this = ::std::move(from);
  }

  inline OrderInfo& operator=(const OrderInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderInfo& operator=(OrderInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderInfo* internal_default_instance() {
    return reinterpret_cast<const OrderInfo*>(
               &_OrderInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(OrderInfo& a, OrderInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderInfo& from) {
    OrderInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "adminspace.OrderInfo";
  }
  protected:
  explicit OrderInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderIdFieldNumber = 1,
    kOrderSenderIdFieldNumber = 2,
    kOrderReceiverIdFieldNumber = 3,
    kOrderStartAddressFieldNumber = 4,
    kOrderEndAddressFieldNumber = 5,
    kOrderMoneyFieldNumber = 6,
    kOrderTimeFieldNumber = 7,
    kOrderStatusFieldNumber = 8,
    kOrderDescriptionFieldNumber = 9,
    kAdminIdFieldNumber = 10,
  };
  // string order_id_ = 1;
  void clear_order_id_();
  const std::string& order_id_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_order_id_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_order_id_();
  PROTOBUF_NODISCARD std::string* release_order_id_();
  void set_allocated_order_id_(std::string* order_id_);
  private:
  const std::string& _internal_order_id_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_id_(const std::string& value);
  std::string* _internal_mutable_order_id_();
  public:

  // string order_sender_id_ = 2;
  void clear_order_sender_id_();
  const std::string& order_sender_id_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_order_sender_id_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_order_sender_id_();
  PROTOBUF_NODISCARD std::string* release_order_sender_id_();
  void set_allocated_order_sender_id_(std::string* order_sender_id_);
  private:
  const std::string& _internal_order_sender_id_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_sender_id_(const std::string& value);
  std::string* _internal_mutable_order_sender_id_();
  public:

  // string order_receiver_id_ = 3;
  void clear_order_receiver_id_();
  const std::string& order_receiver_id_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_order_receiver_id_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_order_receiver_id_();
  PROTOBUF_NODISCARD std::string* release_order_receiver_id_();
  void set_allocated_order_receiver_id_(std::string* order_receiver_id_);
  private:
  const std::string& _internal_order_receiver_id_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_receiver_id_(const std::string& value);
  std::string* _internal_mutable_order_receiver_id_();
  public:

  // string order_start_address_ = 4;
  void clear_order_start_address_();
  const std::string& order_start_address_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_order_start_address_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_order_start_address_();
  PROTOBUF_NODISCARD std::string* release_order_start_address_();
  void set_allocated_order_start_address_(std::string* order_start_address_);
  private:
  const std::string& _internal_order_start_address_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_start_address_(const std::string& value);
  std::string* _internal_mutable_order_start_address_();
  public:

  // string order_end_address_ = 5;
  void clear_order_end_address_();
  const std::string& order_end_address_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_order_end_address_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_order_end_address_();
  PROTOBUF_NODISCARD std::string* release_order_end_address_();
  void set_allocated_order_end_address_(std::string* order_end_address_);
  private:
  const std::string& _internal_order_end_address_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_end_address_(const std::string& value);
  std::string* _internal_mutable_order_end_address_();
  public:

  // string order_money_ = 6;
  void clear_order_money_();
  const std::string& order_money_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_order_money_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_order_money_();
  PROTOBUF_NODISCARD std::string* release_order_money_();
  void set_allocated_order_money_(std::string* order_money_);
  private:
  const std::string& _internal_order_money_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_money_(const std::string& value);
  std::string* _internal_mutable_order_money_();
  public:

  // string order_time_ = 7;
  void clear_order_time_();
  const std::string& order_time_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_order_time_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_order_time_();
  PROTOBUF_NODISCARD std::string* release_order_time_();
  void set_allocated_order_time_(std::string* order_time_);
  private:
  const std::string& _internal_order_time_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_time_(const std::string& value);
  std::string* _internal_mutable_order_time_();
  public:

  // string order_status_ = 8;
  void clear_order_status_();
  const std::string& order_status_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_order_status_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_order_status_();
  PROTOBUF_NODISCARD std::string* release_order_status_();
  void set_allocated_order_status_(std::string* order_status_);
  private:
  const std::string& _internal_order_status_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_status_(const std::string& value);
  std::string* _internal_mutable_order_status_();
  public:

  // string order_description_ = 9;
  void clear_order_description_();
  const std::string& order_description_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_order_description_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_order_description_();
  PROTOBUF_NODISCARD std::string* release_order_description_();
  void set_allocated_order_description_(std::string* order_description_);
  private:
  const std::string& _internal_order_description_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_description_(const std::string& value);
  std::string* _internal_mutable_order_description_();
  public:

  // string admin_id_ = 10;
  void clear_admin_id_();
  const std::string& admin_id_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_admin_id_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_admin_id_();
  PROTOBUF_NODISCARD std::string* release_admin_id_();
  void set_allocated_admin_id_(std::string* admin_id_);
  private:
  const std::string& _internal_admin_id_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_admin_id_(const std::string& value);
  std::string* _internal_mutable_admin_id_();
  public:

  // @@protoc_insertion_point(class_scope:adminspace.OrderInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_id__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_sender_id__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_receiver_id__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_start_address__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_end_address__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_money__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_time__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_status__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_description__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr admin_id__;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myadmin_2eproto;
};
// -------------------------------------------------------------------

class AllOrderList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:adminspace.AllOrderList) */ {
 public:
  inline AllOrderList() : AllOrderList(nullptr) {}
  ~AllOrderList() override;
  explicit PROTOBUF_CONSTEXPR AllOrderList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AllOrderList(const AllOrderList& from);
  AllOrderList(AllOrderList&& from) noexcept
    : AllOrderList() {
    *this = ::std::move(from);
  }

  inline AllOrderList& operator=(const AllOrderList& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllOrderList& operator=(AllOrderList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AllOrderList& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllOrderList* internal_default_instance() {
    return reinterpret_cast<const AllOrderList*>(
               &_AllOrderList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AllOrderList& a, AllOrderList& b) {
    a.Swap(&b);
  }
  inline void Swap(AllOrderList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllOrderList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllOrderList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AllOrderList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AllOrderList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AllOrderList& from) {
    AllOrderList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AllOrderList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "adminspace.AllOrderList";
  }
  protected:
  explicit AllOrderList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderInfoFieldNumber = 3,
    kReturnMessageFieldNumber = 2,
    kReturnResultFieldNumber = 1,
  };
  // repeated .adminspace.OrderInfo order_info_ = 3;
  int order_info__size() const;
  private:
  int _internal_order_info__size() const;
  public:
  void clear_order_info_();
  ::adminspace::OrderInfo* mutable_order_info_(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::adminspace::OrderInfo >*
      mutable_order_info_();
  private:
  const ::adminspace::OrderInfo& _internal_order_info_(int index) const;
  ::adminspace::OrderInfo* _internal_add_order_info_();
  public:
  const ::adminspace::OrderInfo& order_info_(int index) const;
  ::adminspace::OrderInfo* add_order_info_();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::adminspace::OrderInfo >&
      order_info_() const;

  // string return_message_ = 2;
  void clear_return_message_();
  const std::string& return_message_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_return_message_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_return_message_();
  PROTOBUF_NODISCARD std::string* release_return_message_();
  void set_allocated_return_message_(std::string* return_message_);
  private:
  const std::string& _internal_return_message_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_return_message_(const std::string& value);
  std::string* _internal_mutable_return_message_();
  public:

  // bool return_result_ = 1;
  void clear_return_result_();
  bool return_result_() const;
  void set_return_result_(bool value);
  private:
  bool _internal_return_result_() const;
  void _internal_set_return_result_(bool value);
  public:

  // @@protoc_insertion_point(class_scope:adminspace.AllOrderList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::adminspace::OrderInfo > order_info__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr return_message__;
    bool return_result__;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myadmin_2eproto;
};
// -------------------------------------------------------------------

class BaseReply3 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:adminspace.BaseReply3) */ {
 public:
  inline BaseReply3() : BaseReply3(nullptr) {}
  ~BaseReply3() override;
  explicit PROTOBUF_CONSTEXPR BaseReply3(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BaseReply3(const BaseReply3& from);
  BaseReply3(BaseReply3&& from) noexcept
    : BaseReply3() {
    *this = ::std::move(from);
  }

  inline BaseReply3& operator=(const BaseReply3& from) {
    CopyFrom(from);
    return *this;
  }
  inline BaseReply3& operator=(BaseReply3&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BaseReply3& default_instance() {
    return *internal_default_instance();
  }
  static inline const BaseReply3* internal_default_instance() {
    return reinterpret_cast<const BaseReply3*>(
               &_BaseReply3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(BaseReply3& a, BaseReply3& b) {
    a.Swap(&b);
  }
  inline void Swap(BaseReply3* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BaseReply3* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BaseReply3* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BaseReply3>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BaseReply3& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BaseReply3& from) {
    BaseReply3::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BaseReply3* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "adminspace.BaseReply3";
  }
  protected:
  explicit BaseReply3(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReturnMessageFieldNumber = 2,
    kReturnResultFieldNumber = 1,
  };
  // string return_message_ = 2;
  void clear_return_message_();
  const std::string& return_message_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_return_message_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_return_message_();
  PROTOBUF_NODISCARD std::string* release_return_message_();
  void set_allocated_return_message_(std::string* return_message_);
  private:
  const std::string& _internal_return_message_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_return_message_(const std::string& value);
  std::string* _internal_mutable_return_message_();
  public:

  // bool return_result_ = 1;
  void clear_return_result_();
  bool return_result_() const;
  void set_return_result_(bool value);
  private:
  bool _internal_return_result_() const;
  void _internal_set_return_result_(bool value);
  public:

  // @@protoc_insertion_point(class_scope:adminspace.BaseReply3)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr return_message__;
    bool return_result__;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myadmin_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AdminId

// string admin_id_ = 1;
inline void AdminId::clear_admin_id_() {
  _impl_.admin_id__.ClearToEmpty();
}
inline const std::string& AdminId::admin_id_() const {
  // @@protoc_insertion_point(field_get:adminspace.AdminId.admin_id_)
  return _internal_admin_id_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdminId::set_admin_id_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.admin_id__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:adminspace.AdminId.admin_id_)
}
inline std::string* AdminId::mutable_admin_id_() {
  std::string* _s = _internal_mutable_admin_id_();
  // @@protoc_insertion_point(field_mutable:adminspace.AdminId.admin_id_)
  return _s;
}
inline const std::string& AdminId::_internal_admin_id_() const {
  return _impl_.admin_id__.Get();
}
inline void AdminId::_internal_set_admin_id_(const std::string& value) {
  
  _impl_.admin_id__.Set(value, GetArenaForAllocation());
}
inline std::string* AdminId::_internal_mutable_admin_id_() {
  
  return _impl_.admin_id__.Mutable(GetArenaForAllocation());
}
inline std::string* AdminId::release_admin_id_() {
  // @@protoc_insertion_point(field_release:adminspace.AdminId.admin_id_)
  return _impl_.admin_id__.Release();
}
inline void AdminId::set_allocated_admin_id_(std::string* admin_id_) {
  if (admin_id_ != nullptr) {
    
  } else {
    
  }
  _impl_.admin_id__.SetAllocated(admin_id_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.admin_id__.IsDefault()) {
    _impl_.admin_id__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:adminspace.AdminId.admin_id_)
}

// -------------------------------------------------------------------

// ItemInfo

// string item_id_ = 1;
inline void ItemInfo::clear_item_id_() {
  _impl_.item_id__.ClearToEmpty();
}
inline const std::string& ItemInfo::item_id_() const {
  // @@protoc_insertion_point(field_get:adminspace.ItemInfo.item_id_)
  return _internal_item_id_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ItemInfo::set_item_id_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.item_id__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:adminspace.ItemInfo.item_id_)
}
inline std::string* ItemInfo::mutable_item_id_() {
  std::string* _s = _internal_mutable_item_id_();
  // @@protoc_insertion_point(field_mutable:adminspace.ItemInfo.item_id_)
  return _s;
}
inline const std::string& ItemInfo::_internal_item_id_() const {
  return _impl_.item_id__.Get();
}
inline void ItemInfo::_internal_set_item_id_(const std::string& value) {
  
  _impl_.item_id__.Set(value, GetArenaForAllocation());
}
inline std::string* ItemInfo::_internal_mutable_item_id_() {
  
  return _impl_.item_id__.Mutable(GetArenaForAllocation());
}
inline std::string* ItemInfo::release_item_id_() {
  // @@protoc_insertion_point(field_release:adminspace.ItemInfo.item_id_)
  return _impl_.item_id__.Release();
}
inline void ItemInfo::set_allocated_item_id_(std::string* item_id_) {
  if (item_id_ != nullptr) {
    
  } else {
    
  }
  _impl_.item_id__.SetAllocated(item_id_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.item_id__.IsDefault()) {
    _impl_.item_id__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:adminspace.ItemInfo.item_id_)
}

// string item_name_ = 2;
inline void ItemInfo::clear_item_name_() {
  _impl_.item_name__.ClearToEmpty();
}
inline const std::string& ItemInfo::item_name_() const {
  // @@protoc_insertion_point(field_get:adminspace.ItemInfo.item_name_)
  return _internal_item_name_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ItemInfo::set_item_name_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.item_name__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:adminspace.ItemInfo.item_name_)
}
inline std::string* ItemInfo::mutable_item_name_() {
  std::string* _s = _internal_mutable_item_name_();
  // @@protoc_insertion_point(field_mutable:adminspace.ItemInfo.item_name_)
  return _s;
}
inline const std::string& ItemInfo::_internal_item_name_() const {
  return _impl_.item_name__.Get();
}
inline void ItemInfo::_internal_set_item_name_(const std::string& value) {
  
  _impl_.item_name__.Set(value, GetArenaForAllocation());
}
inline std::string* ItemInfo::_internal_mutable_item_name_() {
  
  return _impl_.item_name__.Mutable(GetArenaForAllocation());
}
inline std::string* ItemInfo::release_item_name_() {
  // @@protoc_insertion_point(field_release:adminspace.ItemInfo.item_name_)
  return _impl_.item_name__.Release();
}
inline void ItemInfo::set_allocated_item_name_(std::string* item_name_) {
  if (item_name_ != nullptr) {
    
  } else {
    
  }
  _impl_.item_name__.SetAllocated(item_name_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.item_name__.IsDefault()) {
    _impl_.item_name__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:adminspace.ItemInfo.item_name_)
}

// string item_price_ = 3;
inline void ItemInfo::clear_item_price_() {
  _impl_.item_price__.ClearToEmpty();
}
inline const std::string& ItemInfo::item_price_() const {
  // @@protoc_insertion_point(field_get:adminspace.ItemInfo.item_price_)
  return _internal_item_price_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ItemInfo::set_item_price_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.item_price__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:adminspace.ItemInfo.item_price_)
}
inline std::string* ItemInfo::mutable_item_price_() {
  std::string* _s = _internal_mutable_item_price_();
  // @@protoc_insertion_point(field_mutable:adminspace.ItemInfo.item_price_)
  return _s;
}
inline const std::string& ItemInfo::_internal_item_price_() const {
  return _impl_.item_price__.Get();
}
inline void ItemInfo::_internal_set_item_price_(const std::string& value) {
  
  _impl_.item_price__.Set(value, GetArenaForAllocation());
}
inline std::string* ItemInfo::_internal_mutable_item_price_() {
  
  return _impl_.item_price__.Mutable(GetArenaForAllocation());
}
inline std::string* ItemInfo::release_item_price_() {
  // @@protoc_insertion_point(field_release:adminspace.ItemInfo.item_price_)
  return _impl_.item_price__.Release();
}
inline void ItemInfo::set_allocated_item_price_(std::string* item_price_) {
  if (item_price_ != nullptr) {
    
  } else {
    
  }
  _impl_.item_price__.SetAllocated(item_price_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.item_price__.IsDefault()) {
    _impl_.item_price__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:adminspace.ItemInfo.item_price_)
}

// string item_description_ = 4;
inline void ItemInfo::clear_item_description_() {
  _impl_.item_description__.ClearToEmpty();
}
inline const std::string& ItemInfo::item_description_() const {
  // @@protoc_insertion_point(field_get:adminspace.ItemInfo.item_description_)
  return _internal_item_description_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ItemInfo::set_item_description_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.item_description__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:adminspace.ItemInfo.item_description_)
}
inline std::string* ItemInfo::mutable_item_description_() {
  std::string* _s = _internal_mutable_item_description_();
  // @@protoc_insertion_point(field_mutable:adminspace.ItemInfo.item_description_)
  return _s;
}
inline const std::string& ItemInfo::_internal_item_description_() const {
  return _impl_.item_description__.Get();
}
inline void ItemInfo::_internal_set_item_description_(const std::string& value) {
  
  _impl_.item_description__.Set(value, GetArenaForAllocation());
}
inline std::string* ItemInfo::_internal_mutable_item_description_() {
  
  return _impl_.item_description__.Mutable(GetArenaForAllocation());
}
inline std::string* ItemInfo::release_item_description_() {
  // @@protoc_insertion_point(field_release:adminspace.ItemInfo.item_description_)
  return _impl_.item_description__.Release();
}
inline void ItemInfo::set_allocated_item_description_(std::string* item_description_) {
  if (item_description_ != nullptr) {
    
  } else {
    
  }
  _impl_.item_description__.SetAllocated(item_description_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.item_description__.IsDefault()) {
    _impl_.item_description__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:adminspace.ItemInfo.item_description_)
}

// string admin_id_ = 5;
inline void ItemInfo::clear_admin_id_() {
  _impl_.admin_id__.ClearToEmpty();
}
inline const std::string& ItemInfo::admin_id_() const {
  // @@protoc_insertion_point(field_get:adminspace.ItemInfo.admin_id_)
  return _internal_admin_id_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ItemInfo::set_admin_id_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.admin_id__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:adminspace.ItemInfo.admin_id_)
}
inline std::string* ItemInfo::mutable_admin_id_() {
  std::string* _s = _internal_mutable_admin_id_();
  // @@protoc_insertion_point(field_mutable:adminspace.ItemInfo.admin_id_)
  return _s;
}
inline const std::string& ItemInfo::_internal_admin_id_() const {
  return _impl_.admin_id__.Get();
}
inline void ItemInfo::_internal_set_admin_id_(const std::string& value) {
  
  _impl_.admin_id__.Set(value, GetArenaForAllocation());
}
inline std::string* ItemInfo::_internal_mutable_admin_id_() {
  
  return _impl_.admin_id__.Mutable(GetArenaForAllocation());
}
inline std::string* ItemInfo::release_admin_id_() {
  // @@protoc_insertion_point(field_release:adminspace.ItemInfo.admin_id_)
  return _impl_.admin_id__.Release();
}
inline void ItemInfo::set_allocated_admin_id_(std::string* admin_id_) {
  if (admin_id_ != nullptr) {
    
  } else {
    
  }
  _impl_.admin_id__.SetAllocated(admin_id_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.admin_id__.IsDefault()) {
    _impl_.admin_id__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:adminspace.ItemInfo.admin_id_)
}

// -------------------------------------------------------------------

// AllItemList

// bool return_result_ = 1;
inline void AllItemList::clear_return_result_() {
  _impl_.return_result__ = false;
}
inline bool AllItemList::_internal_return_result_() const {
  return _impl_.return_result__;
}
inline bool AllItemList::return_result_() const {
  // @@protoc_insertion_point(field_get:adminspace.AllItemList.return_result_)
  return _internal_return_result_();
}
inline void AllItemList::_internal_set_return_result_(bool value) {
  
  _impl_.return_result__ = value;
}
inline void AllItemList::set_return_result_(bool value) {
  _internal_set_return_result_(value);
  // @@protoc_insertion_point(field_set:adminspace.AllItemList.return_result_)
}

// string return_message_ = 2;
inline void AllItemList::clear_return_message_() {
  _impl_.return_message__.ClearToEmpty();
}
inline const std::string& AllItemList::return_message_() const {
  // @@protoc_insertion_point(field_get:adminspace.AllItemList.return_message_)
  return _internal_return_message_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AllItemList::set_return_message_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.return_message__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:adminspace.AllItemList.return_message_)
}
inline std::string* AllItemList::mutable_return_message_() {
  std::string* _s = _internal_mutable_return_message_();
  // @@protoc_insertion_point(field_mutable:adminspace.AllItemList.return_message_)
  return _s;
}
inline const std::string& AllItemList::_internal_return_message_() const {
  return _impl_.return_message__.Get();
}
inline void AllItemList::_internal_set_return_message_(const std::string& value) {
  
  _impl_.return_message__.Set(value, GetArenaForAllocation());
}
inline std::string* AllItemList::_internal_mutable_return_message_() {
  
  return _impl_.return_message__.Mutable(GetArenaForAllocation());
}
inline std::string* AllItemList::release_return_message_() {
  // @@protoc_insertion_point(field_release:adminspace.AllItemList.return_message_)
  return _impl_.return_message__.Release();
}
inline void AllItemList::set_allocated_return_message_(std::string* return_message_) {
  if (return_message_ != nullptr) {
    
  } else {
    
  }
  _impl_.return_message__.SetAllocated(return_message_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.return_message__.IsDefault()) {
    _impl_.return_message__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:adminspace.AllItemList.return_message_)
}

// repeated .adminspace.ItemInfo item_info_ = 3;
inline int AllItemList::_internal_item_info__size() const {
  return _impl_.item_info__.size();
}
inline int AllItemList::item_info__size() const {
  return _internal_item_info__size();
}
inline void AllItemList::clear_item_info_() {
  _impl_.item_info__.Clear();
}
inline ::adminspace::ItemInfo* AllItemList::mutable_item_info_(int index) {
  // @@protoc_insertion_point(field_mutable:adminspace.AllItemList.item_info_)
  return _impl_.item_info__.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::adminspace::ItemInfo >*
AllItemList::mutable_item_info_() {
  // @@protoc_insertion_point(field_mutable_list:adminspace.AllItemList.item_info_)
  return &_impl_.item_info__;
}
inline const ::adminspace::ItemInfo& AllItemList::_internal_item_info_(int index) const {
  return _impl_.item_info__.Get(index);
}
inline const ::adminspace::ItemInfo& AllItemList::item_info_(int index) const {
  // @@protoc_insertion_point(field_get:adminspace.AllItemList.item_info_)
  return _internal_item_info_(index);
}
inline ::adminspace::ItemInfo* AllItemList::_internal_add_item_info_() {
  return _impl_.item_info__.Add();
}
inline ::adminspace::ItemInfo* AllItemList::add_item_info_() {
  ::adminspace::ItemInfo* _add = _internal_add_item_info_();
  // @@protoc_insertion_point(field_add:adminspace.AllItemList.item_info_)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::adminspace::ItemInfo >&
AllItemList::item_info_() const {
  // @@protoc_insertion_point(field_list:adminspace.AllItemList.item_info_)
  return _impl_.item_info__;
}

// -------------------------------------------------------------------

// StationInfo

// string station_id_ = 1;
inline void StationInfo::clear_station_id_() {
  _impl_.station_id__.ClearToEmpty();
}
inline const std::string& StationInfo::station_id_() const {
  // @@protoc_insertion_point(field_get:adminspace.StationInfo.station_id_)
  return _internal_station_id_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StationInfo::set_station_id_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.station_id__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:adminspace.StationInfo.station_id_)
}
inline std::string* StationInfo::mutable_station_id_() {
  std::string* _s = _internal_mutable_station_id_();
  // @@protoc_insertion_point(field_mutable:adminspace.StationInfo.station_id_)
  return _s;
}
inline const std::string& StationInfo::_internal_station_id_() const {
  return _impl_.station_id__.Get();
}
inline void StationInfo::_internal_set_station_id_(const std::string& value) {
  
  _impl_.station_id__.Set(value, GetArenaForAllocation());
}
inline std::string* StationInfo::_internal_mutable_station_id_() {
  
  return _impl_.station_id__.Mutable(GetArenaForAllocation());
}
inline std::string* StationInfo::release_station_id_() {
  // @@protoc_insertion_point(field_release:adminspace.StationInfo.station_id_)
  return _impl_.station_id__.Release();
}
inline void StationInfo::set_allocated_station_id_(std::string* station_id_) {
  if (station_id_ != nullptr) {
    
  } else {
    
  }
  _impl_.station_id__.SetAllocated(station_id_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.station_id__.IsDefault()) {
    _impl_.station_id__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:adminspace.StationInfo.station_id_)
}

// string station_name_ = 2;
inline void StationInfo::clear_station_name_() {
  _impl_.station_name__.ClearToEmpty();
}
inline const std::string& StationInfo::station_name_() const {
  // @@protoc_insertion_point(field_get:adminspace.StationInfo.station_name_)
  return _internal_station_name_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StationInfo::set_station_name_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.station_name__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:adminspace.StationInfo.station_name_)
}
inline std::string* StationInfo::mutable_station_name_() {
  std::string* _s = _internal_mutable_station_name_();
  // @@protoc_insertion_point(field_mutable:adminspace.StationInfo.station_name_)
  return _s;
}
inline const std::string& StationInfo::_internal_station_name_() const {
  return _impl_.station_name__.Get();
}
inline void StationInfo::_internal_set_station_name_(const std::string& value) {
  
  _impl_.station_name__.Set(value, GetArenaForAllocation());
}
inline std::string* StationInfo::_internal_mutable_station_name_() {
  
  return _impl_.station_name__.Mutable(GetArenaForAllocation());
}
inline std::string* StationInfo::release_station_name_() {
  // @@protoc_insertion_point(field_release:adminspace.StationInfo.station_name_)
  return _impl_.station_name__.Release();
}
inline void StationInfo::set_allocated_station_name_(std::string* station_name_) {
  if (station_name_ != nullptr) {
    
  } else {
    
  }
  _impl_.station_name__.SetAllocated(station_name_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.station_name__.IsDefault()) {
    _impl_.station_name__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:adminspace.StationInfo.station_name_)
}

// string station_position_ = 3;
inline void StationInfo::clear_station_position_() {
  _impl_.station_position__.ClearToEmpty();
}
inline const std::string& StationInfo::station_position_() const {
  // @@protoc_insertion_point(field_get:adminspace.StationInfo.station_position_)
  return _internal_station_position_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StationInfo::set_station_position_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.station_position__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:adminspace.StationInfo.station_position_)
}
inline std::string* StationInfo::mutable_station_position_() {
  std::string* _s = _internal_mutable_station_position_();
  // @@protoc_insertion_point(field_mutable:adminspace.StationInfo.station_position_)
  return _s;
}
inline const std::string& StationInfo::_internal_station_position_() const {
  return _impl_.station_position__.Get();
}
inline void StationInfo::_internal_set_station_position_(const std::string& value) {
  
  _impl_.station_position__.Set(value, GetArenaForAllocation());
}
inline std::string* StationInfo::_internal_mutable_station_position_() {
  
  return _impl_.station_position__.Mutable(GetArenaForAllocation());
}
inline std::string* StationInfo::release_station_position_() {
  // @@protoc_insertion_point(field_release:adminspace.StationInfo.station_position_)
  return _impl_.station_position__.Release();
}
inline void StationInfo::set_allocated_station_position_(std::string* station_position_) {
  if (station_position_ != nullptr) {
    
  } else {
    
  }
  _impl_.station_position__.SetAllocated(station_position_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.station_position__.IsDefault()) {
    _impl_.station_position__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:adminspace.StationInfo.station_position_)
}

// string station_description_ = 4;
inline void StationInfo::clear_station_description_() {
  _impl_.station_description__.ClearToEmpty();
}
inline const std::string& StationInfo::station_description_() const {
  // @@protoc_insertion_point(field_get:adminspace.StationInfo.station_description_)
  return _internal_station_description_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StationInfo::set_station_description_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.station_description__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:adminspace.StationInfo.station_description_)
}
inline std::string* StationInfo::mutable_station_description_() {
  std::string* _s = _internal_mutable_station_description_();
  // @@protoc_insertion_point(field_mutable:adminspace.StationInfo.station_description_)
  return _s;
}
inline const std::string& StationInfo::_internal_station_description_() const {
  return _impl_.station_description__.Get();
}
inline void StationInfo::_internal_set_station_description_(const std::string& value) {
  
  _impl_.station_description__.Set(value, GetArenaForAllocation());
}
inline std::string* StationInfo::_internal_mutable_station_description_() {
  
  return _impl_.station_description__.Mutable(GetArenaForAllocation());
}
inline std::string* StationInfo::release_station_description_() {
  // @@protoc_insertion_point(field_release:adminspace.StationInfo.station_description_)
  return _impl_.station_description__.Release();
}
inline void StationInfo::set_allocated_station_description_(std::string* station_description_) {
  if (station_description_ != nullptr) {
    
  } else {
    
  }
  _impl_.station_description__.SetAllocated(station_description_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.station_description__.IsDefault()) {
    _impl_.station_description__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:adminspace.StationInfo.station_description_)
}

// string admin_id_ = 5;
inline void StationInfo::clear_admin_id_() {
  _impl_.admin_id__.ClearToEmpty();
}
inline const std::string& StationInfo::admin_id_() const {
  // @@protoc_insertion_point(field_get:adminspace.StationInfo.admin_id_)
  return _internal_admin_id_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StationInfo::set_admin_id_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.admin_id__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:adminspace.StationInfo.admin_id_)
}
inline std::string* StationInfo::mutable_admin_id_() {
  std::string* _s = _internal_mutable_admin_id_();
  // @@protoc_insertion_point(field_mutable:adminspace.StationInfo.admin_id_)
  return _s;
}
inline const std::string& StationInfo::_internal_admin_id_() const {
  return _impl_.admin_id__.Get();
}
inline void StationInfo::_internal_set_admin_id_(const std::string& value) {
  
  _impl_.admin_id__.Set(value, GetArenaForAllocation());
}
inline std::string* StationInfo::_internal_mutable_admin_id_() {
  
  return _impl_.admin_id__.Mutable(GetArenaForAllocation());
}
inline std::string* StationInfo::release_admin_id_() {
  // @@protoc_insertion_point(field_release:adminspace.StationInfo.admin_id_)
  return _impl_.admin_id__.Release();
}
inline void StationInfo::set_allocated_admin_id_(std::string* admin_id_) {
  if (admin_id_ != nullptr) {
    
  } else {
    
  }
  _impl_.admin_id__.SetAllocated(admin_id_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.admin_id__.IsDefault()) {
    _impl_.admin_id__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:adminspace.StationInfo.admin_id_)
}

// -------------------------------------------------------------------

// AllStationList

// bool return_result_ = 1;
inline void AllStationList::clear_return_result_() {
  _impl_.return_result__ = false;
}
inline bool AllStationList::_internal_return_result_() const {
  return _impl_.return_result__;
}
inline bool AllStationList::return_result_() const {
  // @@protoc_insertion_point(field_get:adminspace.AllStationList.return_result_)
  return _internal_return_result_();
}
inline void AllStationList::_internal_set_return_result_(bool value) {
  
  _impl_.return_result__ = value;
}
inline void AllStationList::set_return_result_(bool value) {
  _internal_set_return_result_(value);
  // @@protoc_insertion_point(field_set:adminspace.AllStationList.return_result_)
}

// string return_message_ = 2;
inline void AllStationList::clear_return_message_() {
  _impl_.return_message__.ClearToEmpty();
}
inline const std::string& AllStationList::return_message_() const {
  // @@protoc_insertion_point(field_get:adminspace.AllStationList.return_message_)
  return _internal_return_message_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AllStationList::set_return_message_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.return_message__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:adminspace.AllStationList.return_message_)
}
inline std::string* AllStationList::mutable_return_message_() {
  std::string* _s = _internal_mutable_return_message_();
  // @@protoc_insertion_point(field_mutable:adminspace.AllStationList.return_message_)
  return _s;
}
inline const std::string& AllStationList::_internal_return_message_() const {
  return _impl_.return_message__.Get();
}
inline void AllStationList::_internal_set_return_message_(const std::string& value) {
  
  _impl_.return_message__.Set(value, GetArenaForAllocation());
}
inline std::string* AllStationList::_internal_mutable_return_message_() {
  
  return _impl_.return_message__.Mutable(GetArenaForAllocation());
}
inline std::string* AllStationList::release_return_message_() {
  // @@protoc_insertion_point(field_release:adminspace.AllStationList.return_message_)
  return _impl_.return_message__.Release();
}
inline void AllStationList::set_allocated_return_message_(std::string* return_message_) {
  if (return_message_ != nullptr) {
    
  } else {
    
  }
  _impl_.return_message__.SetAllocated(return_message_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.return_message__.IsDefault()) {
    _impl_.return_message__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:adminspace.AllStationList.return_message_)
}

// repeated .adminspace.StationInfo station_info_ = 3;
inline int AllStationList::_internal_station_info__size() const {
  return _impl_.station_info__.size();
}
inline int AllStationList::station_info__size() const {
  return _internal_station_info__size();
}
inline void AllStationList::clear_station_info_() {
  _impl_.station_info__.Clear();
}
inline ::adminspace::StationInfo* AllStationList::mutable_station_info_(int index) {
  // @@protoc_insertion_point(field_mutable:adminspace.AllStationList.station_info_)
  return _impl_.station_info__.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::adminspace::StationInfo >*
AllStationList::mutable_station_info_() {
  // @@protoc_insertion_point(field_mutable_list:adminspace.AllStationList.station_info_)
  return &_impl_.station_info__;
}
inline const ::adminspace::StationInfo& AllStationList::_internal_station_info_(int index) const {
  return _impl_.station_info__.Get(index);
}
inline const ::adminspace::StationInfo& AllStationList::station_info_(int index) const {
  // @@protoc_insertion_point(field_get:adminspace.AllStationList.station_info_)
  return _internal_station_info_(index);
}
inline ::adminspace::StationInfo* AllStationList::_internal_add_station_info_() {
  return _impl_.station_info__.Add();
}
inline ::adminspace::StationInfo* AllStationList::add_station_info_() {
  ::adminspace::StationInfo* _add = _internal_add_station_info_();
  // @@protoc_insertion_point(field_add:adminspace.AllStationList.station_info_)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::adminspace::StationInfo >&
AllStationList::station_info_() const {
  // @@protoc_insertion_point(field_list:adminspace.AllStationList.station_info_)
  return _impl_.station_info__;
}

// -------------------------------------------------------------------

// OrderInfo

// string order_id_ = 1;
inline void OrderInfo::clear_order_id_() {
  _impl_.order_id__.ClearToEmpty();
}
inline const std::string& OrderInfo::order_id_() const {
  // @@protoc_insertion_point(field_get:adminspace.OrderInfo.order_id_)
  return _internal_order_id_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderInfo::set_order_id_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.order_id__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:adminspace.OrderInfo.order_id_)
}
inline std::string* OrderInfo::mutable_order_id_() {
  std::string* _s = _internal_mutable_order_id_();
  // @@protoc_insertion_point(field_mutable:adminspace.OrderInfo.order_id_)
  return _s;
}
inline const std::string& OrderInfo::_internal_order_id_() const {
  return _impl_.order_id__.Get();
}
inline void OrderInfo::_internal_set_order_id_(const std::string& value) {
  
  _impl_.order_id__.Set(value, GetArenaForAllocation());
}
inline std::string* OrderInfo::_internal_mutable_order_id_() {
  
  return _impl_.order_id__.Mutable(GetArenaForAllocation());
}
inline std::string* OrderInfo::release_order_id_() {
  // @@protoc_insertion_point(field_release:adminspace.OrderInfo.order_id_)
  return _impl_.order_id__.Release();
}
inline void OrderInfo::set_allocated_order_id_(std::string* order_id_) {
  if (order_id_ != nullptr) {
    
  } else {
    
  }
  _impl_.order_id__.SetAllocated(order_id_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.order_id__.IsDefault()) {
    _impl_.order_id__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:adminspace.OrderInfo.order_id_)
}

// string order_sender_id_ = 2;
inline void OrderInfo::clear_order_sender_id_() {
  _impl_.order_sender_id__.ClearToEmpty();
}
inline const std::string& OrderInfo::order_sender_id_() const {
  // @@protoc_insertion_point(field_get:adminspace.OrderInfo.order_sender_id_)
  return _internal_order_sender_id_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderInfo::set_order_sender_id_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.order_sender_id__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:adminspace.OrderInfo.order_sender_id_)
}
inline std::string* OrderInfo::mutable_order_sender_id_() {
  std::string* _s = _internal_mutable_order_sender_id_();
  // @@protoc_insertion_point(field_mutable:adminspace.OrderInfo.order_sender_id_)
  return _s;
}
inline const std::string& OrderInfo::_internal_order_sender_id_() const {
  return _impl_.order_sender_id__.Get();
}
inline void OrderInfo::_internal_set_order_sender_id_(const std::string& value) {
  
  _impl_.order_sender_id__.Set(value, GetArenaForAllocation());
}
inline std::string* OrderInfo::_internal_mutable_order_sender_id_() {
  
  return _impl_.order_sender_id__.Mutable(GetArenaForAllocation());
}
inline std::string* OrderInfo::release_order_sender_id_() {
  // @@protoc_insertion_point(field_release:adminspace.OrderInfo.order_sender_id_)
  return _impl_.order_sender_id__.Release();
}
inline void OrderInfo::set_allocated_order_sender_id_(std::string* order_sender_id_) {
  if (order_sender_id_ != nullptr) {
    
  } else {
    
  }
  _impl_.order_sender_id__.SetAllocated(order_sender_id_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.order_sender_id__.IsDefault()) {
    _impl_.order_sender_id__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:adminspace.OrderInfo.order_sender_id_)
}

// string order_receiver_id_ = 3;
inline void OrderInfo::clear_order_receiver_id_() {
  _impl_.order_receiver_id__.ClearToEmpty();
}
inline const std::string& OrderInfo::order_receiver_id_() const {
  // @@protoc_insertion_point(field_get:adminspace.OrderInfo.order_receiver_id_)
  return _internal_order_receiver_id_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderInfo::set_order_receiver_id_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.order_receiver_id__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:adminspace.OrderInfo.order_receiver_id_)
}
inline std::string* OrderInfo::mutable_order_receiver_id_() {
  std::string* _s = _internal_mutable_order_receiver_id_();
  // @@protoc_insertion_point(field_mutable:adminspace.OrderInfo.order_receiver_id_)
  return _s;
}
inline const std::string& OrderInfo::_internal_order_receiver_id_() const {
  return _impl_.order_receiver_id__.Get();
}
inline void OrderInfo::_internal_set_order_receiver_id_(const std::string& value) {
  
  _impl_.order_receiver_id__.Set(value, GetArenaForAllocation());
}
inline std::string* OrderInfo::_internal_mutable_order_receiver_id_() {
  
  return _impl_.order_receiver_id__.Mutable(GetArenaForAllocation());
}
inline std::string* OrderInfo::release_order_receiver_id_() {
  // @@protoc_insertion_point(field_release:adminspace.OrderInfo.order_receiver_id_)
  return _impl_.order_receiver_id__.Release();
}
inline void OrderInfo::set_allocated_order_receiver_id_(std::string* order_receiver_id_) {
  if (order_receiver_id_ != nullptr) {
    
  } else {
    
  }
  _impl_.order_receiver_id__.SetAllocated(order_receiver_id_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.order_receiver_id__.IsDefault()) {
    _impl_.order_receiver_id__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:adminspace.OrderInfo.order_receiver_id_)
}

// string order_start_address_ = 4;
inline void OrderInfo::clear_order_start_address_() {
  _impl_.order_start_address__.ClearToEmpty();
}
inline const std::string& OrderInfo::order_start_address_() const {
  // @@protoc_insertion_point(field_get:adminspace.OrderInfo.order_start_address_)
  return _internal_order_start_address_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderInfo::set_order_start_address_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.order_start_address__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:adminspace.OrderInfo.order_start_address_)
}
inline std::string* OrderInfo::mutable_order_start_address_() {
  std::string* _s = _internal_mutable_order_start_address_();
  // @@protoc_insertion_point(field_mutable:adminspace.OrderInfo.order_start_address_)
  return _s;
}
inline const std::string& OrderInfo::_internal_order_start_address_() const {
  return _impl_.order_start_address__.Get();
}
inline void OrderInfo::_internal_set_order_start_address_(const std::string& value) {
  
  _impl_.order_start_address__.Set(value, GetArenaForAllocation());
}
inline std::string* OrderInfo::_internal_mutable_order_start_address_() {
  
  return _impl_.order_start_address__.Mutable(GetArenaForAllocation());
}
inline std::string* OrderInfo::release_order_start_address_() {
  // @@protoc_insertion_point(field_release:adminspace.OrderInfo.order_start_address_)
  return _impl_.order_start_address__.Release();
}
inline void OrderInfo::set_allocated_order_start_address_(std::string* order_start_address_) {
  if (order_start_address_ != nullptr) {
    
  } else {
    
  }
  _impl_.order_start_address__.SetAllocated(order_start_address_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.order_start_address__.IsDefault()) {
    _impl_.order_start_address__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:adminspace.OrderInfo.order_start_address_)
}

// string order_end_address_ = 5;
inline void OrderInfo::clear_order_end_address_() {
  _impl_.order_end_address__.ClearToEmpty();
}
inline const std::string& OrderInfo::order_end_address_() const {
  // @@protoc_insertion_point(field_get:adminspace.OrderInfo.order_end_address_)
  return _internal_order_end_address_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderInfo::set_order_end_address_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.order_end_address__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:adminspace.OrderInfo.order_end_address_)
}
inline std::string* OrderInfo::mutable_order_end_address_() {
  std::string* _s = _internal_mutable_order_end_address_();
  // @@protoc_insertion_point(field_mutable:adminspace.OrderInfo.order_end_address_)
  return _s;
}
inline const std::string& OrderInfo::_internal_order_end_address_() const {
  return _impl_.order_end_address__.Get();
}
inline void OrderInfo::_internal_set_order_end_address_(const std::string& value) {
  
  _impl_.order_end_address__.Set(value, GetArenaForAllocation());
}
inline std::string* OrderInfo::_internal_mutable_order_end_address_() {
  
  return _impl_.order_end_address__.Mutable(GetArenaForAllocation());
}
inline std::string* OrderInfo::release_order_end_address_() {
  // @@protoc_insertion_point(field_release:adminspace.OrderInfo.order_end_address_)
  return _impl_.order_end_address__.Release();
}
inline void OrderInfo::set_allocated_order_end_address_(std::string* order_end_address_) {
  if (order_end_address_ != nullptr) {
    
  } else {
    
  }
  _impl_.order_end_address__.SetAllocated(order_end_address_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.order_end_address__.IsDefault()) {
    _impl_.order_end_address__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:adminspace.OrderInfo.order_end_address_)
}

// string order_money_ = 6;
inline void OrderInfo::clear_order_money_() {
  _impl_.order_money__.ClearToEmpty();
}
inline const std::string& OrderInfo::order_money_() const {
  // @@protoc_insertion_point(field_get:adminspace.OrderInfo.order_money_)
  return _internal_order_money_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderInfo::set_order_money_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.order_money__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:adminspace.OrderInfo.order_money_)
}
inline std::string* OrderInfo::mutable_order_money_() {
  std::string* _s = _internal_mutable_order_money_();
  // @@protoc_insertion_point(field_mutable:adminspace.OrderInfo.order_money_)
  return _s;
}
inline const std::string& OrderInfo::_internal_order_money_() const {
  return _impl_.order_money__.Get();
}
inline void OrderInfo::_internal_set_order_money_(const std::string& value) {
  
  _impl_.order_money__.Set(value, GetArenaForAllocation());
}
inline std::string* OrderInfo::_internal_mutable_order_money_() {
  
  return _impl_.order_money__.Mutable(GetArenaForAllocation());
}
inline std::string* OrderInfo::release_order_money_() {
  // @@protoc_insertion_point(field_release:adminspace.OrderInfo.order_money_)
  return _impl_.order_money__.Release();
}
inline void OrderInfo::set_allocated_order_money_(std::string* order_money_) {
  if (order_money_ != nullptr) {
    
  } else {
    
  }
  _impl_.order_money__.SetAllocated(order_money_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.order_money__.IsDefault()) {
    _impl_.order_money__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:adminspace.OrderInfo.order_money_)
}

// string order_time_ = 7;
inline void OrderInfo::clear_order_time_() {
  _impl_.order_time__.ClearToEmpty();
}
inline const std::string& OrderInfo::order_time_() const {
  // @@protoc_insertion_point(field_get:adminspace.OrderInfo.order_time_)
  return _internal_order_time_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderInfo::set_order_time_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.order_time__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:adminspace.OrderInfo.order_time_)
}
inline std::string* OrderInfo::mutable_order_time_() {
  std::string* _s = _internal_mutable_order_time_();
  // @@protoc_insertion_point(field_mutable:adminspace.OrderInfo.order_time_)
  return _s;
}
inline const std::string& OrderInfo::_internal_order_time_() const {
  return _impl_.order_time__.Get();
}
inline void OrderInfo::_internal_set_order_time_(const std::string& value) {
  
  _impl_.order_time__.Set(value, GetArenaForAllocation());
}
inline std::string* OrderInfo::_internal_mutable_order_time_() {
  
  return _impl_.order_time__.Mutable(GetArenaForAllocation());
}
inline std::string* OrderInfo::release_order_time_() {
  // @@protoc_insertion_point(field_release:adminspace.OrderInfo.order_time_)
  return _impl_.order_time__.Release();
}
inline void OrderInfo::set_allocated_order_time_(std::string* order_time_) {
  if (order_time_ != nullptr) {
    
  } else {
    
  }
  _impl_.order_time__.SetAllocated(order_time_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.order_time__.IsDefault()) {
    _impl_.order_time__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:adminspace.OrderInfo.order_time_)
}

// string order_status_ = 8;
inline void OrderInfo::clear_order_status_() {
  _impl_.order_status__.ClearToEmpty();
}
inline const std::string& OrderInfo::order_status_() const {
  // @@protoc_insertion_point(field_get:adminspace.OrderInfo.order_status_)
  return _internal_order_status_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderInfo::set_order_status_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.order_status__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:adminspace.OrderInfo.order_status_)
}
inline std::string* OrderInfo::mutable_order_status_() {
  std::string* _s = _internal_mutable_order_status_();
  // @@protoc_insertion_point(field_mutable:adminspace.OrderInfo.order_status_)
  return _s;
}
inline const std::string& OrderInfo::_internal_order_status_() const {
  return _impl_.order_status__.Get();
}
inline void OrderInfo::_internal_set_order_status_(const std::string& value) {
  
  _impl_.order_status__.Set(value, GetArenaForAllocation());
}
inline std::string* OrderInfo::_internal_mutable_order_status_() {
  
  return _impl_.order_status__.Mutable(GetArenaForAllocation());
}
inline std::string* OrderInfo::release_order_status_() {
  // @@protoc_insertion_point(field_release:adminspace.OrderInfo.order_status_)
  return _impl_.order_status__.Release();
}
inline void OrderInfo::set_allocated_order_status_(std::string* order_status_) {
  if (order_status_ != nullptr) {
    
  } else {
    
  }
  _impl_.order_status__.SetAllocated(order_status_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.order_status__.IsDefault()) {
    _impl_.order_status__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:adminspace.OrderInfo.order_status_)
}

// string order_description_ = 9;
inline void OrderInfo::clear_order_description_() {
  _impl_.order_description__.ClearToEmpty();
}
inline const std::string& OrderInfo::order_description_() const {
  // @@protoc_insertion_point(field_get:adminspace.OrderInfo.order_description_)
  return _internal_order_description_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderInfo::set_order_description_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.order_description__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:adminspace.OrderInfo.order_description_)
}
inline std::string* OrderInfo::mutable_order_description_() {
  std::string* _s = _internal_mutable_order_description_();
  // @@protoc_insertion_point(field_mutable:adminspace.OrderInfo.order_description_)
  return _s;
}
inline const std::string& OrderInfo::_internal_order_description_() const {
  return _impl_.order_description__.Get();
}
inline void OrderInfo::_internal_set_order_description_(const std::string& value) {
  
  _impl_.order_description__.Set(value, GetArenaForAllocation());
}
inline std::string* OrderInfo::_internal_mutable_order_description_() {
  
  return _impl_.order_description__.Mutable(GetArenaForAllocation());
}
inline std::string* OrderInfo::release_order_description_() {
  // @@protoc_insertion_point(field_release:adminspace.OrderInfo.order_description_)
  return _impl_.order_description__.Release();
}
inline void OrderInfo::set_allocated_order_description_(std::string* order_description_) {
  if (order_description_ != nullptr) {
    
  } else {
    
  }
  _impl_.order_description__.SetAllocated(order_description_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.order_description__.IsDefault()) {
    _impl_.order_description__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:adminspace.OrderInfo.order_description_)
}

// string admin_id_ = 10;
inline void OrderInfo::clear_admin_id_() {
  _impl_.admin_id__.ClearToEmpty();
}
inline const std::string& OrderInfo::admin_id_() const {
  // @@protoc_insertion_point(field_get:adminspace.OrderInfo.admin_id_)
  return _internal_admin_id_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderInfo::set_admin_id_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.admin_id__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:adminspace.OrderInfo.admin_id_)
}
inline std::string* OrderInfo::mutable_admin_id_() {
  std::string* _s = _internal_mutable_admin_id_();
  // @@protoc_insertion_point(field_mutable:adminspace.OrderInfo.admin_id_)
  return _s;
}
inline const std::string& OrderInfo::_internal_admin_id_() const {
  return _impl_.admin_id__.Get();
}
inline void OrderInfo::_internal_set_admin_id_(const std::string& value) {
  
  _impl_.admin_id__.Set(value, GetArenaForAllocation());
}
inline std::string* OrderInfo::_internal_mutable_admin_id_() {
  
  return _impl_.admin_id__.Mutable(GetArenaForAllocation());
}
inline std::string* OrderInfo::release_admin_id_() {
  // @@protoc_insertion_point(field_release:adminspace.OrderInfo.admin_id_)
  return _impl_.admin_id__.Release();
}
inline void OrderInfo::set_allocated_admin_id_(std::string* admin_id_) {
  if (admin_id_ != nullptr) {
    
  } else {
    
  }
  _impl_.admin_id__.SetAllocated(admin_id_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.admin_id__.IsDefault()) {
    _impl_.admin_id__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:adminspace.OrderInfo.admin_id_)
}

// -------------------------------------------------------------------

// AllOrderList

// bool return_result_ = 1;
inline void AllOrderList::clear_return_result_() {
  _impl_.return_result__ = false;
}
inline bool AllOrderList::_internal_return_result_() const {
  return _impl_.return_result__;
}
inline bool AllOrderList::return_result_() const {
  // @@protoc_insertion_point(field_get:adminspace.AllOrderList.return_result_)
  return _internal_return_result_();
}
inline void AllOrderList::_internal_set_return_result_(bool value) {
  
  _impl_.return_result__ = value;
}
inline void AllOrderList::set_return_result_(bool value) {
  _internal_set_return_result_(value);
  // @@protoc_insertion_point(field_set:adminspace.AllOrderList.return_result_)
}

// string return_message_ = 2;
inline void AllOrderList::clear_return_message_() {
  _impl_.return_message__.ClearToEmpty();
}
inline const std::string& AllOrderList::return_message_() const {
  // @@protoc_insertion_point(field_get:adminspace.AllOrderList.return_message_)
  return _internal_return_message_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AllOrderList::set_return_message_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.return_message__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:adminspace.AllOrderList.return_message_)
}
inline std::string* AllOrderList::mutable_return_message_() {
  std::string* _s = _internal_mutable_return_message_();
  // @@protoc_insertion_point(field_mutable:adminspace.AllOrderList.return_message_)
  return _s;
}
inline const std::string& AllOrderList::_internal_return_message_() const {
  return _impl_.return_message__.Get();
}
inline void AllOrderList::_internal_set_return_message_(const std::string& value) {
  
  _impl_.return_message__.Set(value, GetArenaForAllocation());
}
inline std::string* AllOrderList::_internal_mutable_return_message_() {
  
  return _impl_.return_message__.Mutable(GetArenaForAllocation());
}
inline std::string* AllOrderList::release_return_message_() {
  // @@protoc_insertion_point(field_release:adminspace.AllOrderList.return_message_)
  return _impl_.return_message__.Release();
}
inline void AllOrderList::set_allocated_return_message_(std::string* return_message_) {
  if (return_message_ != nullptr) {
    
  } else {
    
  }
  _impl_.return_message__.SetAllocated(return_message_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.return_message__.IsDefault()) {
    _impl_.return_message__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:adminspace.AllOrderList.return_message_)
}

// repeated .adminspace.OrderInfo order_info_ = 3;
inline int AllOrderList::_internal_order_info__size() const {
  return _impl_.order_info__.size();
}
inline int AllOrderList::order_info__size() const {
  return _internal_order_info__size();
}
inline void AllOrderList::clear_order_info_() {
  _impl_.order_info__.Clear();
}
inline ::adminspace::OrderInfo* AllOrderList::mutable_order_info_(int index) {
  // @@protoc_insertion_point(field_mutable:adminspace.AllOrderList.order_info_)
  return _impl_.order_info__.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::adminspace::OrderInfo >*
AllOrderList::mutable_order_info_() {
  // @@protoc_insertion_point(field_mutable_list:adminspace.AllOrderList.order_info_)
  return &_impl_.order_info__;
}
inline const ::adminspace::OrderInfo& AllOrderList::_internal_order_info_(int index) const {
  return _impl_.order_info__.Get(index);
}
inline const ::adminspace::OrderInfo& AllOrderList::order_info_(int index) const {
  // @@protoc_insertion_point(field_get:adminspace.AllOrderList.order_info_)
  return _internal_order_info_(index);
}
inline ::adminspace::OrderInfo* AllOrderList::_internal_add_order_info_() {
  return _impl_.order_info__.Add();
}
inline ::adminspace::OrderInfo* AllOrderList::add_order_info_() {
  ::adminspace::OrderInfo* _add = _internal_add_order_info_();
  // @@protoc_insertion_point(field_add:adminspace.AllOrderList.order_info_)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::adminspace::OrderInfo >&
AllOrderList::order_info_() const {
  // @@protoc_insertion_point(field_list:adminspace.AllOrderList.order_info_)
  return _impl_.order_info__;
}

// -------------------------------------------------------------------

// BaseReply3

// bool return_result_ = 1;
inline void BaseReply3::clear_return_result_() {
  _impl_.return_result__ = false;
}
inline bool BaseReply3::_internal_return_result_() const {
  return _impl_.return_result__;
}
inline bool BaseReply3::return_result_() const {
  // @@protoc_insertion_point(field_get:adminspace.BaseReply3.return_result_)
  return _internal_return_result_();
}
inline void BaseReply3::_internal_set_return_result_(bool value) {
  
  _impl_.return_result__ = value;
}
inline void BaseReply3::set_return_result_(bool value) {
  _internal_set_return_result_(value);
  // @@protoc_insertion_point(field_set:adminspace.BaseReply3.return_result_)
}

// string return_message_ = 2;
inline void BaseReply3::clear_return_message_() {
  _impl_.return_message__.ClearToEmpty();
}
inline const std::string& BaseReply3::return_message_() const {
  // @@protoc_insertion_point(field_get:adminspace.BaseReply3.return_message_)
  return _internal_return_message_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BaseReply3::set_return_message_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.return_message__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:adminspace.BaseReply3.return_message_)
}
inline std::string* BaseReply3::mutable_return_message_() {
  std::string* _s = _internal_mutable_return_message_();
  // @@protoc_insertion_point(field_mutable:adminspace.BaseReply3.return_message_)
  return _s;
}
inline const std::string& BaseReply3::_internal_return_message_() const {
  return _impl_.return_message__.Get();
}
inline void BaseReply3::_internal_set_return_message_(const std::string& value) {
  
  _impl_.return_message__.Set(value, GetArenaForAllocation());
}
inline std::string* BaseReply3::_internal_mutable_return_message_() {
  
  return _impl_.return_message__.Mutable(GetArenaForAllocation());
}
inline std::string* BaseReply3::release_return_message_() {
  // @@protoc_insertion_point(field_release:adminspace.BaseReply3.return_message_)
  return _impl_.return_message__.Release();
}
inline void BaseReply3::set_allocated_return_message_(std::string* return_message_) {
  if (return_message_ != nullptr) {
    
  } else {
    
  }
  _impl_.return_message__.SetAllocated(return_message_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.return_message__.IsDefault()) {
    _impl_.return_message__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:adminspace.BaseReply3.return_message_)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace adminspace

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_myadmin_2eproto
