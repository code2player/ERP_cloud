// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: myuser.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_myuser_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_myuser_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_myuser_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_myuser_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_myuser_2eproto;
namespace userspace {
class BaseReply;
struct BaseReplyDefaultTypeInternal;
extern BaseReplyDefaultTypeInternal _BaseReply_default_instance_;
class OrderDetail;
struct OrderDetailDefaultTypeInternal;
extern OrderDetailDefaultTypeInternal _OrderDetail_default_instance_;
class OrderId;
struct OrderIdDefaultTypeInternal;
extern OrderIdDefaultTypeInternal _OrderId_default_instance_;
class OrderItem;
struct OrderItemDefaultTypeInternal;
extern OrderItemDefaultTypeInternal _OrderItem_default_instance_;
class OrderList;
struct OrderListDefaultTypeInternal;
extern OrderListDefaultTypeInternal _OrderList_default_instance_;
class OrderTransport;
struct OrderTransportDefaultTypeInternal;
extern OrderTransportDefaultTypeInternal _OrderTransport_default_instance_;
class SpecificOrder;
struct SpecificOrderDefaultTypeInternal;
extern SpecificOrderDefaultTypeInternal _SpecificOrder_default_instance_;
class UpdateOrderStateRequest;
struct UpdateOrderStateRequestDefaultTypeInternal;
extern UpdateOrderStateRequestDefaultTypeInternal _UpdateOrderStateRequest_default_instance_;
class UserId;
struct UserIdDefaultTypeInternal;
extern UserIdDefaultTypeInternal _UserId_default_instance_;
}  // namespace userspace
PROTOBUF_NAMESPACE_OPEN
template<> ::userspace::BaseReply* Arena::CreateMaybeMessage<::userspace::BaseReply>(Arena*);
template<> ::userspace::OrderDetail* Arena::CreateMaybeMessage<::userspace::OrderDetail>(Arena*);
template<> ::userspace::OrderId* Arena::CreateMaybeMessage<::userspace::OrderId>(Arena*);
template<> ::userspace::OrderItem* Arena::CreateMaybeMessage<::userspace::OrderItem>(Arena*);
template<> ::userspace::OrderList* Arena::CreateMaybeMessage<::userspace::OrderList>(Arena*);
template<> ::userspace::OrderTransport* Arena::CreateMaybeMessage<::userspace::OrderTransport>(Arena*);
template<> ::userspace::SpecificOrder* Arena::CreateMaybeMessage<::userspace::SpecificOrder>(Arena*);
template<> ::userspace::UpdateOrderStateRequest* Arena::CreateMaybeMessage<::userspace::UpdateOrderStateRequest>(Arena*);
template<> ::userspace::UserId* Arena::CreateMaybeMessage<::userspace::UserId>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace userspace {

// ===================================================================

class UserId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:userspace.UserId) */ {
 public:
  inline UserId() : UserId(nullptr) {}
  ~UserId() override;
  explicit PROTOBUF_CONSTEXPR UserId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserId(const UserId& from);
  UserId(UserId&& from) noexcept
    : UserId() {
    *this = ::std::move(from);
  }

  inline UserId& operator=(const UserId& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserId& operator=(UserId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserId& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserId* internal_default_instance() {
    return reinterpret_cast<const UserId*>(
               &_UserId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(UserId& a, UserId& b) {
    a.Swap(&b);
  }
  inline void Swap(UserId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserId& from) {
    UserId::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "userspace.UserId";
  }
  protected:
  explicit UserId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserPhoneFieldNumber = 1,
  };
  // string user_phone_ = 1;
  void clear_user_phone_();
  const std::string& user_phone_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_phone_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_phone_();
  PROTOBUF_NODISCARD std::string* release_user_phone_();
  void set_allocated_user_phone_(std::string* user_phone_);
  private:
  const std::string& _internal_user_phone_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_phone_(const std::string& value);
  std::string* _internal_mutable_user_phone_();
  public:

  // @@protoc_insertion_point(class_scope:userspace.UserId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_phone__;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myuser_2eproto;
};
// -------------------------------------------------------------------

class OrderItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:userspace.OrderItem) */ {
 public:
  inline OrderItem() : OrderItem(nullptr) {}
  ~OrderItem() override;
  explicit PROTOBUF_CONSTEXPR OrderItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderItem(const OrderItem& from);
  OrderItem(OrderItem&& from) noexcept
    : OrderItem() {
    *this = ::std::move(from);
  }

  inline OrderItem& operator=(const OrderItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderItem& operator=(OrderItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderItem* internal_default_instance() {
    return reinterpret_cast<const OrderItem*>(
               &_OrderItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(OrderItem& a, OrderItem& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderItem& from) {
    OrderItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "userspace.OrderItem";
  }
  protected:
  explicit OrderItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemIdFieldNumber = 1,
    kItemNameFieldNumber = 2,
    kItemPriceFieldNumber = 3,
    kItemDescriptionFieldNumber = 4,
    kItemNumberFieldNumber = 5,
  };
  // string item_id_ = 1;
  void clear_item_id_();
  const std::string& item_id_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_item_id_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_item_id_();
  PROTOBUF_NODISCARD std::string* release_item_id_();
  void set_allocated_item_id_(std::string* item_id_);
  private:
  const std::string& _internal_item_id_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item_id_(const std::string& value);
  std::string* _internal_mutable_item_id_();
  public:

  // string item_name_ = 2;
  void clear_item_name_();
  const std::string& item_name_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_item_name_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_item_name_();
  PROTOBUF_NODISCARD std::string* release_item_name_();
  void set_allocated_item_name_(std::string* item_name_);
  private:
  const std::string& _internal_item_name_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item_name_(const std::string& value);
  std::string* _internal_mutable_item_name_();
  public:

  // string item_price_ = 3;
  void clear_item_price_();
  const std::string& item_price_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_item_price_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_item_price_();
  PROTOBUF_NODISCARD std::string* release_item_price_();
  void set_allocated_item_price_(std::string* item_price_);
  private:
  const std::string& _internal_item_price_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item_price_(const std::string& value);
  std::string* _internal_mutable_item_price_();
  public:

  // string item_description_ = 4;
  void clear_item_description_();
  const std::string& item_description_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_item_description_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_item_description_();
  PROTOBUF_NODISCARD std::string* release_item_description_();
  void set_allocated_item_description_(std::string* item_description_);
  private:
  const std::string& _internal_item_description_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item_description_(const std::string& value);
  std::string* _internal_mutable_item_description_();
  public:

  // int32 item_number_ = 5;
  void clear_item_number_();
  int32_t item_number_() const;
  void set_item_number_(int32_t value);
  private:
  int32_t _internal_item_number_() const;
  void _internal_set_item_number_(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:userspace.OrderItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr item_id__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr item_name__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr item_price__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr item_description__;
    int32_t item_number__;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myuser_2eproto;
};
// -------------------------------------------------------------------

class OrderDetail final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:userspace.OrderDetail) */ {
 public:
  inline OrderDetail() : OrderDetail(nullptr) {}
  ~OrderDetail() override;
  explicit PROTOBUF_CONSTEXPR OrderDetail(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderDetail(const OrderDetail& from);
  OrderDetail(OrderDetail&& from) noexcept
    : OrderDetail() {
    *this = ::std::move(from);
  }

  inline OrderDetail& operator=(const OrderDetail& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderDetail& operator=(OrderDetail&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderDetail& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderDetail* internal_default_instance() {
    return reinterpret_cast<const OrderDetail*>(
               &_OrderDetail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(OrderDetail& a, OrderDetail& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderDetail* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderDetail* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderDetail* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderDetail>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderDetail& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderDetail& from) {
    OrderDetail::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderDetail* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "userspace.OrderDetail";
  }
  protected:
  explicit OrderDetail(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemInfoFieldNumber = 10,
    kOrderIdFieldNumber = 1,
    kOrderSenderIdFieldNumber = 2,
    kOrderReceiverIdFieldNumber = 3,
    kOrderStartAddressFieldNumber = 4,
    kOrderEndAddressFieldNumber = 5,
    kOrderMoneyFieldNumber = 6,
    kOrderTimeFieldNumber = 7,
    kOrderStatusFieldNumber = 8,
    kOrderDescriptionFieldNumber = 9,
  };
  // repeated .userspace.OrderItem item_info_ = 10;
  int item_info__size() const;
  private:
  int _internal_item_info__size() const;
  public:
  void clear_item_info_();
  ::userspace::OrderItem* mutable_item_info_(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::userspace::OrderItem >*
      mutable_item_info_();
  private:
  const ::userspace::OrderItem& _internal_item_info_(int index) const;
  ::userspace::OrderItem* _internal_add_item_info_();
  public:
  const ::userspace::OrderItem& item_info_(int index) const;
  ::userspace::OrderItem* add_item_info_();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::userspace::OrderItem >&
      item_info_() const;

  // string order_id_ = 1;
  void clear_order_id_();
  const std::string& order_id_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_order_id_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_order_id_();
  PROTOBUF_NODISCARD std::string* release_order_id_();
  void set_allocated_order_id_(std::string* order_id_);
  private:
  const std::string& _internal_order_id_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_id_(const std::string& value);
  std::string* _internal_mutable_order_id_();
  public:

  // string order_sender_id_ = 2;
  void clear_order_sender_id_();
  const std::string& order_sender_id_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_order_sender_id_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_order_sender_id_();
  PROTOBUF_NODISCARD std::string* release_order_sender_id_();
  void set_allocated_order_sender_id_(std::string* order_sender_id_);
  private:
  const std::string& _internal_order_sender_id_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_sender_id_(const std::string& value);
  std::string* _internal_mutable_order_sender_id_();
  public:

  // string order_receiver_id_ = 3;
  void clear_order_receiver_id_();
  const std::string& order_receiver_id_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_order_receiver_id_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_order_receiver_id_();
  PROTOBUF_NODISCARD std::string* release_order_receiver_id_();
  void set_allocated_order_receiver_id_(std::string* order_receiver_id_);
  private:
  const std::string& _internal_order_receiver_id_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_receiver_id_(const std::string& value);
  std::string* _internal_mutable_order_receiver_id_();
  public:

  // string order_start_address_ = 4;
  void clear_order_start_address_();
  const std::string& order_start_address_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_order_start_address_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_order_start_address_();
  PROTOBUF_NODISCARD std::string* release_order_start_address_();
  void set_allocated_order_start_address_(std::string* order_start_address_);
  private:
  const std::string& _internal_order_start_address_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_start_address_(const std::string& value);
  std::string* _internal_mutable_order_start_address_();
  public:

  // string order_end_address_ = 5;
  void clear_order_end_address_();
  const std::string& order_end_address_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_order_end_address_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_order_end_address_();
  PROTOBUF_NODISCARD std::string* release_order_end_address_();
  void set_allocated_order_end_address_(std::string* order_end_address_);
  private:
  const std::string& _internal_order_end_address_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_end_address_(const std::string& value);
  std::string* _internal_mutable_order_end_address_();
  public:

  // string order_money_ = 6;
  void clear_order_money_();
  const std::string& order_money_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_order_money_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_order_money_();
  PROTOBUF_NODISCARD std::string* release_order_money_();
  void set_allocated_order_money_(std::string* order_money_);
  private:
  const std::string& _internal_order_money_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_money_(const std::string& value);
  std::string* _internal_mutable_order_money_();
  public:

  // string order_time_ = 7;
  void clear_order_time_();
  const std::string& order_time_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_order_time_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_order_time_();
  PROTOBUF_NODISCARD std::string* release_order_time_();
  void set_allocated_order_time_(std::string* order_time_);
  private:
  const std::string& _internal_order_time_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_time_(const std::string& value);
  std::string* _internal_mutable_order_time_();
  public:

  // string order_status_ = 8;
  void clear_order_status_();
  const std::string& order_status_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_order_status_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_order_status_();
  PROTOBUF_NODISCARD std::string* release_order_status_();
  void set_allocated_order_status_(std::string* order_status_);
  private:
  const std::string& _internal_order_status_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_status_(const std::string& value);
  std::string* _internal_mutable_order_status_();
  public:

  // string order_description_ = 9;
  void clear_order_description_();
  const std::string& order_description_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_order_description_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_order_description_();
  PROTOBUF_NODISCARD std::string* release_order_description_();
  void set_allocated_order_description_(std::string* order_description_);
  private:
  const std::string& _internal_order_description_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_description_(const std::string& value);
  std::string* _internal_mutable_order_description_();
  public:

  // @@protoc_insertion_point(class_scope:userspace.OrderDetail)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::userspace::OrderItem > item_info__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_id__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_sender_id__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_receiver_id__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_start_address__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_end_address__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_money__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_time__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_status__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_description__;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myuser_2eproto;
};
// -------------------------------------------------------------------

class OrderList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:userspace.OrderList) */ {
 public:
  inline OrderList() : OrderList(nullptr) {}
  ~OrderList() override;
  explicit PROTOBUF_CONSTEXPR OrderList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderList(const OrderList& from);
  OrderList(OrderList&& from) noexcept
    : OrderList() {
    *this = ::std::move(from);
  }

  inline OrderList& operator=(const OrderList& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderList& operator=(OrderList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderList& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderList* internal_default_instance() {
    return reinterpret_cast<const OrderList*>(
               &_OrderList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(OrderList& a, OrderList& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderList& from) {
    OrderList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "userspace.OrderList";
  }
  protected:
  explicit OrderList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderSenderListFieldNumber = 2,
    kOrderReceiverListFieldNumber = 3,
    kReturnResultFieldNumber = 1,
  };
  // repeated .userspace.OrderDetail order_sender_list_ = 2;
  int order_sender_list__size() const;
  private:
  int _internal_order_sender_list__size() const;
  public:
  void clear_order_sender_list_();
  ::userspace::OrderDetail* mutable_order_sender_list_(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::userspace::OrderDetail >*
      mutable_order_sender_list_();
  private:
  const ::userspace::OrderDetail& _internal_order_sender_list_(int index) const;
  ::userspace::OrderDetail* _internal_add_order_sender_list_();
  public:
  const ::userspace::OrderDetail& order_sender_list_(int index) const;
  ::userspace::OrderDetail* add_order_sender_list_();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::userspace::OrderDetail >&
      order_sender_list_() const;

  // repeated .userspace.OrderDetail order_receiver_list_ = 3;
  int order_receiver_list__size() const;
  private:
  int _internal_order_receiver_list__size() const;
  public:
  void clear_order_receiver_list_();
  ::userspace::OrderDetail* mutable_order_receiver_list_(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::userspace::OrderDetail >*
      mutable_order_receiver_list_();
  private:
  const ::userspace::OrderDetail& _internal_order_receiver_list_(int index) const;
  ::userspace::OrderDetail* _internal_add_order_receiver_list_();
  public:
  const ::userspace::OrderDetail& order_receiver_list_(int index) const;
  ::userspace::OrderDetail* add_order_receiver_list_();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::userspace::OrderDetail >&
      order_receiver_list_() const;

  // bool return_result_ = 1;
  void clear_return_result_();
  bool return_result_() const;
  void set_return_result_(bool value);
  private:
  bool _internal_return_result_() const;
  void _internal_set_return_result_(bool value);
  public:

  // @@protoc_insertion_point(class_scope:userspace.OrderList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::userspace::OrderDetail > order_sender_list__;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::userspace::OrderDetail > order_receiver_list__;
    bool return_result__;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myuser_2eproto;
};
// -------------------------------------------------------------------

class UpdateOrderStateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:userspace.UpdateOrderStateRequest) */ {
 public:
  inline UpdateOrderStateRequest() : UpdateOrderStateRequest(nullptr) {}
  ~UpdateOrderStateRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateOrderStateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateOrderStateRequest(const UpdateOrderStateRequest& from);
  UpdateOrderStateRequest(UpdateOrderStateRequest&& from) noexcept
    : UpdateOrderStateRequest() {
    *this = ::std::move(from);
  }

  inline UpdateOrderStateRequest& operator=(const UpdateOrderStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateOrderStateRequest& operator=(UpdateOrderStateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateOrderStateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateOrderStateRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateOrderStateRequest*>(
               &_UpdateOrderStateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(UpdateOrderStateRequest& a, UpdateOrderStateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateOrderStateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateOrderStateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateOrderStateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateOrderStateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateOrderStateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateOrderStateRequest& from) {
    UpdateOrderStateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateOrderStateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "userspace.UpdateOrderStateRequest";
  }
  protected:
  explicit UpdateOrderStateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderIdFieldNumber = 1,
    kOrderStatusFieldNumber = 2,
  };
  // string order_id_ = 1;
  void clear_order_id_();
  const std::string& order_id_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_order_id_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_order_id_();
  PROTOBUF_NODISCARD std::string* release_order_id_();
  void set_allocated_order_id_(std::string* order_id_);
  private:
  const std::string& _internal_order_id_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_id_(const std::string& value);
  std::string* _internal_mutable_order_id_();
  public:

  // string order_status_ = 2;
  void clear_order_status_();
  const std::string& order_status_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_order_status_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_order_status_();
  PROTOBUF_NODISCARD std::string* release_order_status_();
  void set_allocated_order_status_(std::string* order_status_);
  private:
  const std::string& _internal_order_status_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_status_(const std::string& value);
  std::string* _internal_mutable_order_status_();
  public:

  // @@protoc_insertion_point(class_scope:userspace.UpdateOrderStateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_id__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_status__;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myuser_2eproto;
};
// -------------------------------------------------------------------

class BaseReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:userspace.BaseReply) */ {
 public:
  inline BaseReply() : BaseReply(nullptr) {}
  ~BaseReply() override;
  explicit PROTOBUF_CONSTEXPR BaseReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BaseReply(const BaseReply& from);
  BaseReply(BaseReply&& from) noexcept
    : BaseReply() {
    *this = ::std::move(from);
  }

  inline BaseReply& operator=(const BaseReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline BaseReply& operator=(BaseReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BaseReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const BaseReply* internal_default_instance() {
    return reinterpret_cast<const BaseReply*>(
               &_BaseReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(BaseReply& a, BaseReply& b) {
    a.Swap(&b);
  }
  inline void Swap(BaseReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BaseReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BaseReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BaseReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BaseReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BaseReply& from) {
    BaseReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BaseReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "userspace.BaseReply";
  }
  protected:
  explicit BaseReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReturnMessageFieldNumber = 2,
    kReturnResultFieldNumber = 1,
  };
  // string return_message_ = 2;
  void clear_return_message_();
  const std::string& return_message_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_return_message_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_return_message_();
  PROTOBUF_NODISCARD std::string* release_return_message_();
  void set_allocated_return_message_(std::string* return_message_);
  private:
  const std::string& _internal_return_message_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_return_message_(const std::string& value);
  std::string* _internal_mutable_return_message_();
  public:

  // bool return_result_ = 1;
  void clear_return_result_();
  bool return_result_() const;
  void set_return_result_(bool value);
  private:
  bool _internal_return_result_() const;
  void _internal_set_return_result_(bool value);
  public:

  // @@protoc_insertion_point(class_scope:userspace.BaseReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr return_message__;
    bool return_result__;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myuser_2eproto;
};
// -------------------------------------------------------------------

class OrderId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:userspace.OrderId) */ {
 public:
  inline OrderId() : OrderId(nullptr) {}
  ~OrderId() override;
  explicit PROTOBUF_CONSTEXPR OrderId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderId(const OrderId& from);
  OrderId(OrderId&& from) noexcept
    : OrderId() {
    *this = ::std::move(from);
  }

  inline OrderId& operator=(const OrderId& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderId& operator=(OrderId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderId& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderId* internal_default_instance() {
    return reinterpret_cast<const OrderId*>(
               &_OrderId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(OrderId& a, OrderId& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderId& from) {
    OrderId::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "userspace.OrderId";
  }
  protected:
  explicit OrderId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderIdFieldNumber = 1,
  };
  // string order_id_ = 1;
  void clear_order_id_();
  const std::string& order_id_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_order_id_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_order_id_();
  PROTOBUF_NODISCARD std::string* release_order_id_();
  void set_allocated_order_id_(std::string* order_id_);
  private:
  const std::string& _internal_order_id_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_id_(const std::string& value);
  std::string* _internal_mutable_order_id_();
  public:

  // @@protoc_insertion_point(class_scope:userspace.OrderId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_id__;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myuser_2eproto;
};
// -------------------------------------------------------------------

class OrderTransport final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:userspace.OrderTransport) */ {
 public:
  inline OrderTransport() : OrderTransport(nullptr) {}
  ~OrderTransport() override;
  explicit PROTOBUF_CONSTEXPR OrderTransport(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderTransport(const OrderTransport& from);
  OrderTransport(OrderTransport&& from) noexcept
    : OrderTransport() {
    *this = ::std::move(from);
  }

  inline OrderTransport& operator=(const OrderTransport& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderTransport& operator=(OrderTransport&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderTransport& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderTransport* internal_default_instance() {
    return reinterpret_cast<const OrderTransport*>(
               &_OrderTransport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(OrderTransport& a, OrderTransport& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderTransport* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderTransport* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderTransport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderTransport>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderTransport& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderTransport& from) {
    OrderTransport::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderTransport* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "userspace.OrderTransport";
  }
  protected:
  explicit OrderTransport(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransportTimeFieldNumber = 1,
    kTransportDescriptionFieldNumber = 2,
  };
  // string transport_time_ = 1;
  void clear_transport_time_();
  const std::string& transport_time_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_transport_time_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_transport_time_();
  PROTOBUF_NODISCARD std::string* release_transport_time_();
  void set_allocated_transport_time_(std::string* transport_time_);
  private:
  const std::string& _internal_transport_time_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transport_time_(const std::string& value);
  std::string* _internal_mutable_transport_time_();
  public:

  // string transport_description_ = 2;
  void clear_transport_description_();
  const std::string& transport_description_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_transport_description_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_transport_description_();
  PROTOBUF_NODISCARD std::string* release_transport_description_();
  void set_allocated_transport_description_(std::string* transport_description_);
  private:
  const std::string& _internal_transport_description_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transport_description_(const std::string& value);
  std::string* _internal_mutable_transport_description_();
  public:

  // @@protoc_insertion_point(class_scope:userspace.OrderTransport)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transport_time__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transport_description__;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myuser_2eproto;
};
// -------------------------------------------------------------------

class SpecificOrder final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:userspace.SpecificOrder) */ {
 public:
  inline SpecificOrder() : SpecificOrder(nullptr) {}
  ~SpecificOrder() override;
  explicit PROTOBUF_CONSTEXPR SpecificOrder(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpecificOrder(const SpecificOrder& from);
  SpecificOrder(SpecificOrder&& from) noexcept
    : SpecificOrder() {
    *this = ::std::move(from);
  }

  inline SpecificOrder& operator=(const SpecificOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpecificOrder& operator=(SpecificOrder&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpecificOrder& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpecificOrder* internal_default_instance() {
    return reinterpret_cast<const SpecificOrder*>(
               &_SpecificOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SpecificOrder& a, SpecificOrder& b) {
    a.Swap(&b);
  }
  inline void Swap(SpecificOrder* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpecificOrder* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpecificOrder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpecificOrder>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpecificOrder& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SpecificOrder& from) {
    SpecificOrder::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpecificOrder* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "userspace.SpecificOrder";
  }
  protected:
  explicit SpecificOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransportListFieldNumber = 3,
    kItemListFieldNumber = 4,
    kReturnMessageFieldNumber = 2,
    kReturnResultFieldNumber = 1,
  };
  // repeated .userspace.OrderTransport transport_list_ = 3;
  int transport_list__size() const;
  private:
  int _internal_transport_list__size() const;
  public:
  void clear_transport_list_();
  ::userspace::OrderTransport* mutable_transport_list_(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::userspace::OrderTransport >*
      mutable_transport_list_();
  private:
  const ::userspace::OrderTransport& _internal_transport_list_(int index) const;
  ::userspace::OrderTransport* _internal_add_transport_list_();
  public:
  const ::userspace::OrderTransport& transport_list_(int index) const;
  ::userspace::OrderTransport* add_transport_list_();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::userspace::OrderTransport >&
      transport_list_() const;

  // repeated .userspace.OrderItem item_list_ = 4;
  int item_list__size() const;
  private:
  int _internal_item_list__size() const;
  public:
  void clear_item_list_();
  ::userspace::OrderItem* mutable_item_list_(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::userspace::OrderItem >*
      mutable_item_list_();
  private:
  const ::userspace::OrderItem& _internal_item_list_(int index) const;
  ::userspace::OrderItem* _internal_add_item_list_();
  public:
  const ::userspace::OrderItem& item_list_(int index) const;
  ::userspace::OrderItem* add_item_list_();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::userspace::OrderItem >&
      item_list_() const;

  // string return_message_ = 2;
  void clear_return_message_();
  const std::string& return_message_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_return_message_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_return_message_();
  PROTOBUF_NODISCARD std::string* release_return_message_();
  void set_allocated_return_message_(std::string* return_message_);
  private:
  const std::string& _internal_return_message_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_return_message_(const std::string& value);
  std::string* _internal_mutable_return_message_();
  public:

  // bool return_result_ = 1;
  void clear_return_result_();
  bool return_result_() const;
  void set_return_result_(bool value);
  private:
  bool _internal_return_result_() const;
  void _internal_set_return_result_(bool value);
  public:

  // @@protoc_insertion_point(class_scope:userspace.SpecificOrder)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::userspace::OrderTransport > transport_list__;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::userspace::OrderItem > item_list__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr return_message__;
    bool return_result__;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myuser_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// UserId

// string user_phone_ = 1;
inline void UserId::clear_user_phone_() {
  _impl_.user_phone__.ClearToEmpty();
}
inline const std::string& UserId::user_phone_() const {
  // @@protoc_insertion_point(field_get:userspace.UserId.user_phone_)
  return _internal_user_phone_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserId::set_user_phone_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_phone__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:userspace.UserId.user_phone_)
}
inline std::string* UserId::mutable_user_phone_() {
  std::string* _s = _internal_mutable_user_phone_();
  // @@protoc_insertion_point(field_mutable:userspace.UserId.user_phone_)
  return _s;
}
inline const std::string& UserId::_internal_user_phone_() const {
  return _impl_.user_phone__.Get();
}
inline void UserId::_internal_set_user_phone_(const std::string& value) {
  
  _impl_.user_phone__.Set(value, GetArenaForAllocation());
}
inline std::string* UserId::_internal_mutable_user_phone_() {
  
  return _impl_.user_phone__.Mutable(GetArenaForAllocation());
}
inline std::string* UserId::release_user_phone_() {
  // @@protoc_insertion_point(field_release:userspace.UserId.user_phone_)
  return _impl_.user_phone__.Release();
}
inline void UserId::set_allocated_user_phone_(std::string* user_phone_) {
  if (user_phone_ != nullptr) {
    
  } else {
    
  }
  _impl_.user_phone__.SetAllocated(user_phone_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_phone__.IsDefault()) {
    _impl_.user_phone__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:userspace.UserId.user_phone_)
}

// -------------------------------------------------------------------

// OrderItem

// string item_id_ = 1;
inline void OrderItem::clear_item_id_() {
  _impl_.item_id__.ClearToEmpty();
}
inline const std::string& OrderItem::item_id_() const {
  // @@protoc_insertion_point(field_get:userspace.OrderItem.item_id_)
  return _internal_item_id_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderItem::set_item_id_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.item_id__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:userspace.OrderItem.item_id_)
}
inline std::string* OrderItem::mutable_item_id_() {
  std::string* _s = _internal_mutable_item_id_();
  // @@protoc_insertion_point(field_mutable:userspace.OrderItem.item_id_)
  return _s;
}
inline const std::string& OrderItem::_internal_item_id_() const {
  return _impl_.item_id__.Get();
}
inline void OrderItem::_internal_set_item_id_(const std::string& value) {
  
  _impl_.item_id__.Set(value, GetArenaForAllocation());
}
inline std::string* OrderItem::_internal_mutable_item_id_() {
  
  return _impl_.item_id__.Mutable(GetArenaForAllocation());
}
inline std::string* OrderItem::release_item_id_() {
  // @@protoc_insertion_point(field_release:userspace.OrderItem.item_id_)
  return _impl_.item_id__.Release();
}
inline void OrderItem::set_allocated_item_id_(std::string* item_id_) {
  if (item_id_ != nullptr) {
    
  } else {
    
  }
  _impl_.item_id__.SetAllocated(item_id_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.item_id__.IsDefault()) {
    _impl_.item_id__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:userspace.OrderItem.item_id_)
}

// string item_name_ = 2;
inline void OrderItem::clear_item_name_() {
  _impl_.item_name__.ClearToEmpty();
}
inline const std::string& OrderItem::item_name_() const {
  // @@protoc_insertion_point(field_get:userspace.OrderItem.item_name_)
  return _internal_item_name_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderItem::set_item_name_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.item_name__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:userspace.OrderItem.item_name_)
}
inline std::string* OrderItem::mutable_item_name_() {
  std::string* _s = _internal_mutable_item_name_();
  // @@protoc_insertion_point(field_mutable:userspace.OrderItem.item_name_)
  return _s;
}
inline const std::string& OrderItem::_internal_item_name_() const {
  return _impl_.item_name__.Get();
}
inline void OrderItem::_internal_set_item_name_(const std::string& value) {
  
  _impl_.item_name__.Set(value, GetArenaForAllocation());
}
inline std::string* OrderItem::_internal_mutable_item_name_() {
  
  return _impl_.item_name__.Mutable(GetArenaForAllocation());
}
inline std::string* OrderItem::release_item_name_() {
  // @@protoc_insertion_point(field_release:userspace.OrderItem.item_name_)
  return _impl_.item_name__.Release();
}
inline void OrderItem::set_allocated_item_name_(std::string* item_name_) {
  if (item_name_ != nullptr) {
    
  } else {
    
  }
  _impl_.item_name__.SetAllocated(item_name_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.item_name__.IsDefault()) {
    _impl_.item_name__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:userspace.OrderItem.item_name_)
}

// string item_price_ = 3;
inline void OrderItem::clear_item_price_() {
  _impl_.item_price__.ClearToEmpty();
}
inline const std::string& OrderItem::item_price_() const {
  // @@protoc_insertion_point(field_get:userspace.OrderItem.item_price_)
  return _internal_item_price_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderItem::set_item_price_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.item_price__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:userspace.OrderItem.item_price_)
}
inline std::string* OrderItem::mutable_item_price_() {
  std::string* _s = _internal_mutable_item_price_();
  // @@protoc_insertion_point(field_mutable:userspace.OrderItem.item_price_)
  return _s;
}
inline const std::string& OrderItem::_internal_item_price_() const {
  return _impl_.item_price__.Get();
}
inline void OrderItem::_internal_set_item_price_(const std::string& value) {
  
  _impl_.item_price__.Set(value, GetArenaForAllocation());
}
inline std::string* OrderItem::_internal_mutable_item_price_() {
  
  return _impl_.item_price__.Mutable(GetArenaForAllocation());
}
inline std::string* OrderItem::release_item_price_() {
  // @@protoc_insertion_point(field_release:userspace.OrderItem.item_price_)
  return _impl_.item_price__.Release();
}
inline void OrderItem::set_allocated_item_price_(std::string* item_price_) {
  if (item_price_ != nullptr) {
    
  } else {
    
  }
  _impl_.item_price__.SetAllocated(item_price_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.item_price__.IsDefault()) {
    _impl_.item_price__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:userspace.OrderItem.item_price_)
}

// string item_description_ = 4;
inline void OrderItem::clear_item_description_() {
  _impl_.item_description__.ClearToEmpty();
}
inline const std::string& OrderItem::item_description_() const {
  // @@protoc_insertion_point(field_get:userspace.OrderItem.item_description_)
  return _internal_item_description_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderItem::set_item_description_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.item_description__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:userspace.OrderItem.item_description_)
}
inline std::string* OrderItem::mutable_item_description_() {
  std::string* _s = _internal_mutable_item_description_();
  // @@protoc_insertion_point(field_mutable:userspace.OrderItem.item_description_)
  return _s;
}
inline const std::string& OrderItem::_internal_item_description_() const {
  return _impl_.item_description__.Get();
}
inline void OrderItem::_internal_set_item_description_(const std::string& value) {
  
  _impl_.item_description__.Set(value, GetArenaForAllocation());
}
inline std::string* OrderItem::_internal_mutable_item_description_() {
  
  return _impl_.item_description__.Mutable(GetArenaForAllocation());
}
inline std::string* OrderItem::release_item_description_() {
  // @@protoc_insertion_point(field_release:userspace.OrderItem.item_description_)
  return _impl_.item_description__.Release();
}
inline void OrderItem::set_allocated_item_description_(std::string* item_description_) {
  if (item_description_ != nullptr) {
    
  } else {
    
  }
  _impl_.item_description__.SetAllocated(item_description_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.item_description__.IsDefault()) {
    _impl_.item_description__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:userspace.OrderItem.item_description_)
}

// int32 item_number_ = 5;
inline void OrderItem::clear_item_number_() {
  _impl_.item_number__ = 0;
}
inline int32_t OrderItem::_internal_item_number_() const {
  return _impl_.item_number__;
}
inline int32_t OrderItem::item_number_() const {
  // @@protoc_insertion_point(field_get:userspace.OrderItem.item_number_)
  return _internal_item_number_();
}
inline void OrderItem::_internal_set_item_number_(int32_t value) {
  
  _impl_.item_number__ = value;
}
inline void OrderItem::set_item_number_(int32_t value) {
  _internal_set_item_number_(value);
  // @@protoc_insertion_point(field_set:userspace.OrderItem.item_number_)
}

// -------------------------------------------------------------------

// OrderDetail

// string order_id_ = 1;
inline void OrderDetail::clear_order_id_() {
  _impl_.order_id__.ClearToEmpty();
}
inline const std::string& OrderDetail::order_id_() const {
  // @@protoc_insertion_point(field_get:userspace.OrderDetail.order_id_)
  return _internal_order_id_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderDetail::set_order_id_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.order_id__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:userspace.OrderDetail.order_id_)
}
inline std::string* OrderDetail::mutable_order_id_() {
  std::string* _s = _internal_mutable_order_id_();
  // @@protoc_insertion_point(field_mutable:userspace.OrderDetail.order_id_)
  return _s;
}
inline const std::string& OrderDetail::_internal_order_id_() const {
  return _impl_.order_id__.Get();
}
inline void OrderDetail::_internal_set_order_id_(const std::string& value) {
  
  _impl_.order_id__.Set(value, GetArenaForAllocation());
}
inline std::string* OrderDetail::_internal_mutable_order_id_() {
  
  return _impl_.order_id__.Mutable(GetArenaForAllocation());
}
inline std::string* OrderDetail::release_order_id_() {
  // @@protoc_insertion_point(field_release:userspace.OrderDetail.order_id_)
  return _impl_.order_id__.Release();
}
inline void OrderDetail::set_allocated_order_id_(std::string* order_id_) {
  if (order_id_ != nullptr) {
    
  } else {
    
  }
  _impl_.order_id__.SetAllocated(order_id_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.order_id__.IsDefault()) {
    _impl_.order_id__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:userspace.OrderDetail.order_id_)
}

// string order_sender_id_ = 2;
inline void OrderDetail::clear_order_sender_id_() {
  _impl_.order_sender_id__.ClearToEmpty();
}
inline const std::string& OrderDetail::order_sender_id_() const {
  // @@protoc_insertion_point(field_get:userspace.OrderDetail.order_sender_id_)
  return _internal_order_sender_id_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderDetail::set_order_sender_id_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.order_sender_id__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:userspace.OrderDetail.order_sender_id_)
}
inline std::string* OrderDetail::mutable_order_sender_id_() {
  std::string* _s = _internal_mutable_order_sender_id_();
  // @@protoc_insertion_point(field_mutable:userspace.OrderDetail.order_sender_id_)
  return _s;
}
inline const std::string& OrderDetail::_internal_order_sender_id_() const {
  return _impl_.order_sender_id__.Get();
}
inline void OrderDetail::_internal_set_order_sender_id_(const std::string& value) {
  
  _impl_.order_sender_id__.Set(value, GetArenaForAllocation());
}
inline std::string* OrderDetail::_internal_mutable_order_sender_id_() {
  
  return _impl_.order_sender_id__.Mutable(GetArenaForAllocation());
}
inline std::string* OrderDetail::release_order_sender_id_() {
  // @@protoc_insertion_point(field_release:userspace.OrderDetail.order_sender_id_)
  return _impl_.order_sender_id__.Release();
}
inline void OrderDetail::set_allocated_order_sender_id_(std::string* order_sender_id_) {
  if (order_sender_id_ != nullptr) {
    
  } else {
    
  }
  _impl_.order_sender_id__.SetAllocated(order_sender_id_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.order_sender_id__.IsDefault()) {
    _impl_.order_sender_id__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:userspace.OrderDetail.order_sender_id_)
}

// string order_receiver_id_ = 3;
inline void OrderDetail::clear_order_receiver_id_() {
  _impl_.order_receiver_id__.ClearToEmpty();
}
inline const std::string& OrderDetail::order_receiver_id_() const {
  // @@protoc_insertion_point(field_get:userspace.OrderDetail.order_receiver_id_)
  return _internal_order_receiver_id_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderDetail::set_order_receiver_id_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.order_receiver_id__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:userspace.OrderDetail.order_receiver_id_)
}
inline std::string* OrderDetail::mutable_order_receiver_id_() {
  std::string* _s = _internal_mutable_order_receiver_id_();
  // @@protoc_insertion_point(field_mutable:userspace.OrderDetail.order_receiver_id_)
  return _s;
}
inline const std::string& OrderDetail::_internal_order_receiver_id_() const {
  return _impl_.order_receiver_id__.Get();
}
inline void OrderDetail::_internal_set_order_receiver_id_(const std::string& value) {
  
  _impl_.order_receiver_id__.Set(value, GetArenaForAllocation());
}
inline std::string* OrderDetail::_internal_mutable_order_receiver_id_() {
  
  return _impl_.order_receiver_id__.Mutable(GetArenaForAllocation());
}
inline std::string* OrderDetail::release_order_receiver_id_() {
  // @@protoc_insertion_point(field_release:userspace.OrderDetail.order_receiver_id_)
  return _impl_.order_receiver_id__.Release();
}
inline void OrderDetail::set_allocated_order_receiver_id_(std::string* order_receiver_id_) {
  if (order_receiver_id_ != nullptr) {
    
  } else {
    
  }
  _impl_.order_receiver_id__.SetAllocated(order_receiver_id_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.order_receiver_id__.IsDefault()) {
    _impl_.order_receiver_id__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:userspace.OrderDetail.order_receiver_id_)
}

// string order_start_address_ = 4;
inline void OrderDetail::clear_order_start_address_() {
  _impl_.order_start_address__.ClearToEmpty();
}
inline const std::string& OrderDetail::order_start_address_() const {
  // @@protoc_insertion_point(field_get:userspace.OrderDetail.order_start_address_)
  return _internal_order_start_address_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderDetail::set_order_start_address_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.order_start_address__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:userspace.OrderDetail.order_start_address_)
}
inline std::string* OrderDetail::mutable_order_start_address_() {
  std::string* _s = _internal_mutable_order_start_address_();
  // @@protoc_insertion_point(field_mutable:userspace.OrderDetail.order_start_address_)
  return _s;
}
inline const std::string& OrderDetail::_internal_order_start_address_() const {
  return _impl_.order_start_address__.Get();
}
inline void OrderDetail::_internal_set_order_start_address_(const std::string& value) {
  
  _impl_.order_start_address__.Set(value, GetArenaForAllocation());
}
inline std::string* OrderDetail::_internal_mutable_order_start_address_() {
  
  return _impl_.order_start_address__.Mutable(GetArenaForAllocation());
}
inline std::string* OrderDetail::release_order_start_address_() {
  // @@protoc_insertion_point(field_release:userspace.OrderDetail.order_start_address_)
  return _impl_.order_start_address__.Release();
}
inline void OrderDetail::set_allocated_order_start_address_(std::string* order_start_address_) {
  if (order_start_address_ != nullptr) {
    
  } else {
    
  }
  _impl_.order_start_address__.SetAllocated(order_start_address_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.order_start_address__.IsDefault()) {
    _impl_.order_start_address__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:userspace.OrderDetail.order_start_address_)
}

// string order_end_address_ = 5;
inline void OrderDetail::clear_order_end_address_() {
  _impl_.order_end_address__.ClearToEmpty();
}
inline const std::string& OrderDetail::order_end_address_() const {
  // @@protoc_insertion_point(field_get:userspace.OrderDetail.order_end_address_)
  return _internal_order_end_address_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderDetail::set_order_end_address_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.order_end_address__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:userspace.OrderDetail.order_end_address_)
}
inline std::string* OrderDetail::mutable_order_end_address_() {
  std::string* _s = _internal_mutable_order_end_address_();
  // @@protoc_insertion_point(field_mutable:userspace.OrderDetail.order_end_address_)
  return _s;
}
inline const std::string& OrderDetail::_internal_order_end_address_() const {
  return _impl_.order_end_address__.Get();
}
inline void OrderDetail::_internal_set_order_end_address_(const std::string& value) {
  
  _impl_.order_end_address__.Set(value, GetArenaForAllocation());
}
inline std::string* OrderDetail::_internal_mutable_order_end_address_() {
  
  return _impl_.order_end_address__.Mutable(GetArenaForAllocation());
}
inline std::string* OrderDetail::release_order_end_address_() {
  // @@protoc_insertion_point(field_release:userspace.OrderDetail.order_end_address_)
  return _impl_.order_end_address__.Release();
}
inline void OrderDetail::set_allocated_order_end_address_(std::string* order_end_address_) {
  if (order_end_address_ != nullptr) {
    
  } else {
    
  }
  _impl_.order_end_address__.SetAllocated(order_end_address_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.order_end_address__.IsDefault()) {
    _impl_.order_end_address__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:userspace.OrderDetail.order_end_address_)
}

// string order_money_ = 6;
inline void OrderDetail::clear_order_money_() {
  _impl_.order_money__.ClearToEmpty();
}
inline const std::string& OrderDetail::order_money_() const {
  // @@protoc_insertion_point(field_get:userspace.OrderDetail.order_money_)
  return _internal_order_money_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderDetail::set_order_money_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.order_money__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:userspace.OrderDetail.order_money_)
}
inline std::string* OrderDetail::mutable_order_money_() {
  std::string* _s = _internal_mutable_order_money_();
  // @@protoc_insertion_point(field_mutable:userspace.OrderDetail.order_money_)
  return _s;
}
inline const std::string& OrderDetail::_internal_order_money_() const {
  return _impl_.order_money__.Get();
}
inline void OrderDetail::_internal_set_order_money_(const std::string& value) {
  
  _impl_.order_money__.Set(value, GetArenaForAllocation());
}
inline std::string* OrderDetail::_internal_mutable_order_money_() {
  
  return _impl_.order_money__.Mutable(GetArenaForAllocation());
}
inline std::string* OrderDetail::release_order_money_() {
  // @@protoc_insertion_point(field_release:userspace.OrderDetail.order_money_)
  return _impl_.order_money__.Release();
}
inline void OrderDetail::set_allocated_order_money_(std::string* order_money_) {
  if (order_money_ != nullptr) {
    
  } else {
    
  }
  _impl_.order_money__.SetAllocated(order_money_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.order_money__.IsDefault()) {
    _impl_.order_money__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:userspace.OrderDetail.order_money_)
}

// string order_time_ = 7;
inline void OrderDetail::clear_order_time_() {
  _impl_.order_time__.ClearToEmpty();
}
inline const std::string& OrderDetail::order_time_() const {
  // @@protoc_insertion_point(field_get:userspace.OrderDetail.order_time_)
  return _internal_order_time_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderDetail::set_order_time_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.order_time__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:userspace.OrderDetail.order_time_)
}
inline std::string* OrderDetail::mutable_order_time_() {
  std::string* _s = _internal_mutable_order_time_();
  // @@protoc_insertion_point(field_mutable:userspace.OrderDetail.order_time_)
  return _s;
}
inline const std::string& OrderDetail::_internal_order_time_() const {
  return _impl_.order_time__.Get();
}
inline void OrderDetail::_internal_set_order_time_(const std::string& value) {
  
  _impl_.order_time__.Set(value, GetArenaForAllocation());
}
inline std::string* OrderDetail::_internal_mutable_order_time_() {
  
  return _impl_.order_time__.Mutable(GetArenaForAllocation());
}
inline std::string* OrderDetail::release_order_time_() {
  // @@protoc_insertion_point(field_release:userspace.OrderDetail.order_time_)
  return _impl_.order_time__.Release();
}
inline void OrderDetail::set_allocated_order_time_(std::string* order_time_) {
  if (order_time_ != nullptr) {
    
  } else {
    
  }
  _impl_.order_time__.SetAllocated(order_time_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.order_time__.IsDefault()) {
    _impl_.order_time__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:userspace.OrderDetail.order_time_)
}

// string order_status_ = 8;
inline void OrderDetail::clear_order_status_() {
  _impl_.order_status__.ClearToEmpty();
}
inline const std::string& OrderDetail::order_status_() const {
  // @@protoc_insertion_point(field_get:userspace.OrderDetail.order_status_)
  return _internal_order_status_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderDetail::set_order_status_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.order_status__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:userspace.OrderDetail.order_status_)
}
inline std::string* OrderDetail::mutable_order_status_() {
  std::string* _s = _internal_mutable_order_status_();
  // @@protoc_insertion_point(field_mutable:userspace.OrderDetail.order_status_)
  return _s;
}
inline const std::string& OrderDetail::_internal_order_status_() const {
  return _impl_.order_status__.Get();
}
inline void OrderDetail::_internal_set_order_status_(const std::string& value) {
  
  _impl_.order_status__.Set(value, GetArenaForAllocation());
}
inline std::string* OrderDetail::_internal_mutable_order_status_() {
  
  return _impl_.order_status__.Mutable(GetArenaForAllocation());
}
inline std::string* OrderDetail::release_order_status_() {
  // @@protoc_insertion_point(field_release:userspace.OrderDetail.order_status_)
  return _impl_.order_status__.Release();
}
inline void OrderDetail::set_allocated_order_status_(std::string* order_status_) {
  if (order_status_ != nullptr) {
    
  } else {
    
  }
  _impl_.order_status__.SetAllocated(order_status_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.order_status__.IsDefault()) {
    _impl_.order_status__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:userspace.OrderDetail.order_status_)
}

// string order_description_ = 9;
inline void OrderDetail::clear_order_description_() {
  _impl_.order_description__.ClearToEmpty();
}
inline const std::string& OrderDetail::order_description_() const {
  // @@protoc_insertion_point(field_get:userspace.OrderDetail.order_description_)
  return _internal_order_description_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderDetail::set_order_description_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.order_description__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:userspace.OrderDetail.order_description_)
}
inline std::string* OrderDetail::mutable_order_description_() {
  std::string* _s = _internal_mutable_order_description_();
  // @@protoc_insertion_point(field_mutable:userspace.OrderDetail.order_description_)
  return _s;
}
inline const std::string& OrderDetail::_internal_order_description_() const {
  return _impl_.order_description__.Get();
}
inline void OrderDetail::_internal_set_order_description_(const std::string& value) {
  
  _impl_.order_description__.Set(value, GetArenaForAllocation());
}
inline std::string* OrderDetail::_internal_mutable_order_description_() {
  
  return _impl_.order_description__.Mutable(GetArenaForAllocation());
}
inline std::string* OrderDetail::release_order_description_() {
  // @@protoc_insertion_point(field_release:userspace.OrderDetail.order_description_)
  return _impl_.order_description__.Release();
}
inline void OrderDetail::set_allocated_order_description_(std::string* order_description_) {
  if (order_description_ != nullptr) {
    
  } else {
    
  }
  _impl_.order_description__.SetAllocated(order_description_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.order_description__.IsDefault()) {
    _impl_.order_description__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:userspace.OrderDetail.order_description_)
}

// repeated .userspace.OrderItem item_info_ = 10;
inline int OrderDetail::_internal_item_info__size() const {
  return _impl_.item_info__.size();
}
inline int OrderDetail::item_info__size() const {
  return _internal_item_info__size();
}
inline void OrderDetail::clear_item_info_() {
  _impl_.item_info__.Clear();
}
inline ::userspace::OrderItem* OrderDetail::mutable_item_info_(int index) {
  // @@protoc_insertion_point(field_mutable:userspace.OrderDetail.item_info_)
  return _impl_.item_info__.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::userspace::OrderItem >*
OrderDetail::mutable_item_info_() {
  // @@protoc_insertion_point(field_mutable_list:userspace.OrderDetail.item_info_)
  return &_impl_.item_info__;
}
inline const ::userspace::OrderItem& OrderDetail::_internal_item_info_(int index) const {
  return _impl_.item_info__.Get(index);
}
inline const ::userspace::OrderItem& OrderDetail::item_info_(int index) const {
  // @@protoc_insertion_point(field_get:userspace.OrderDetail.item_info_)
  return _internal_item_info_(index);
}
inline ::userspace::OrderItem* OrderDetail::_internal_add_item_info_() {
  return _impl_.item_info__.Add();
}
inline ::userspace::OrderItem* OrderDetail::add_item_info_() {
  ::userspace::OrderItem* _add = _internal_add_item_info_();
  // @@protoc_insertion_point(field_add:userspace.OrderDetail.item_info_)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::userspace::OrderItem >&
OrderDetail::item_info_() const {
  // @@protoc_insertion_point(field_list:userspace.OrderDetail.item_info_)
  return _impl_.item_info__;
}

// -------------------------------------------------------------------

// OrderList

// bool return_result_ = 1;
inline void OrderList::clear_return_result_() {
  _impl_.return_result__ = false;
}
inline bool OrderList::_internal_return_result_() const {
  return _impl_.return_result__;
}
inline bool OrderList::return_result_() const {
  // @@protoc_insertion_point(field_get:userspace.OrderList.return_result_)
  return _internal_return_result_();
}
inline void OrderList::_internal_set_return_result_(bool value) {
  
  _impl_.return_result__ = value;
}
inline void OrderList::set_return_result_(bool value) {
  _internal_set_return_result_(value);
  // @@protoc_insertion_point(field_set:userspace.OrderList.return_result_)
}

// repeated .userspace.OrderDetail order_sender_list_ = 2;
inline int OrderList::_internal_order_sender_list__size() const {
  return _impl_.order_sender_list__.size();
}
inline int OrderList::order_sender_list__size() const {
  return _internal_order_sender_list__size();
}
inline void OrderList::clear_order_sender_list_() {
  _impl_.order_sender_list__.Clear();
}
inline ::userspace::OrderDetail* OrderList::mutable_order_sender_list_(int index) {
  // @@protoc_insertion_point(field_mutable:userspace.OrderList.order_sender_list_)
  return _impl_.order_sender_list__.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::userspace::OrderDetail >*
OrderList::mutable_order_sender_list_() {
  // @@protoc_insertion_point(field_mutable_list:userspace.OrderList.order_sender_list_)
  return &_impl_.order_sender_list__;
}
inline const ::userspace::OrderDetail& OrderList::_internal_order_sender_list_(int index) const {
  return _impl_.order_sender_list__.Get(index);
}
inline const ::userspace::OrderDetail& OrderList::order_sender_list_(int index) const {
  // @@protoc_insertion_point(field_get:userspace.OrderList.order_sender_list_)
  return _internal_order_sender_list_(index);
}
inline ::userspace::OrderDetail* OrderList::_internal_add_order_sender_list_() {
  return _impl_.order_sender_list__.Add();
}
inline ::userspace::OrderDetail* OrderList::add_order_sender_list_() {
  ::userspace::OrderDetail* _add = _internal_add_order_sender_list_();
  // @@protoc_insertion_point(field_add:userspace.OrderList.order_sender_list_)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::userspace::OrderDetail >&
OrderList::order_sender_list_() const {
  // @@protoc_insertion_point(field_list:userspace.OrderList.order_sender_list_)
  return _impl_.order_sender_list__;
}

// repeated .userspace.OrderDetail order_receiver_list_ = 3;
inline int OrderList::_internal_order_receiver_list__size() const {
  return _impl_.order_receiver_list__.size();
}
inline int OrderList::order_receiver_list__size() const {
  return _internal_order_receiver_list__size();
}
inline void OrderList::clear_order_receiver_list_() {
  _impl_.order_receiver_list__.Clear();
}
inline ::userspace::OrderDetail* OrderList::mutable_order_receiver_list_(int index) {
  // @@protoc_insertion_point(field_mutable:userspace.OrderList.order_receiver_list_)
  return _impl_.order_receiver_list__.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::userspace::OrderDetail >*
OrderList::mutable_order_receiver_list_() {
  // @@protoc_insertion_point(field_mutable_list:userspace.OrderList.order_receiver_list_)
  return &_impl_.order_receiver_list__;
}
inline const ::userspace::OrderDetail& OrderList::_internal_order_receiver_list_(int index) const {
  return _impl_.order_receiver_list__.Get(index);
}
inline const ::userspace::OrderDetail& OrderList::order_receiver_list_(int index) const {
  // @@protoc_insertion_point(field_get:userspace.OrderList.order_receiver_list_)
  return _internal_order_receiver_list_(index);
}
inline ::userspace::OrderDetail* OrderList::_internal_add_order_receiver_list_() {
  return _impl_.order_receiver_list__.Add();
}
inline ::userspace::OrderDetail* OrderList::add_order_receiver_list_() {
  ::userspace::OrderDetail* _add = _internal_add_order_receiver_list_();
  // @@protoc_insertion_point(field_add:userspace.OrderList.order_receiver_list_)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::userspace::OrderDetail >&
OrderList::order_receiver_list_() const {
  // @@protoc_insertion_point(field_list:userspace.OrderList.order_receiver_list_)
  return _impl_.order_receiver_list__;
}

// -------------------------------------------------------------------

// UpdateOrderStateRequest

// string order_id_ = 1;
inline void UpdateOrderStateRequest::clear_order_id_() {
  _impl_.order_id__.ClearToEmpty();
}
inline const std::string& UpdateOrderStateRequest::order_id_() const {
  // @@protoc_insertion_point(field_get:userspace.UpdateOrderStateRequest.order_id_)
  return _internal_order_id_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateOrderStateRequest::set_order_id_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.order_id__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:userspace.UpdateOrderStateRequest.order_id_)
}
inline std::string* UpdateOrderStateRequest::mutable_order_id_() {
  std::string* _s = _internal_mutable_order_id_();
  // @@protoc_insertion_point(field_mutable:userspace.UpdateOrderStateRequest.order_id_)
  return _s;
}
inline const std::string& UpdateOrderStateRequest::_internal_order_id_() const {
  return _impl_.order_id__.Get();
}
inline void UpdateOrderStateRequest::_internal_set_order_id_(const std::string& value) {
  
  _impl_.order_id__.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateOrderStateRequest::_internal_mutable_order_id_() {
  
  return _impl_.order_id__.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateOrderStateRequest::release_order_id_() {
  // @@protoc_insertion_point(field_release:userspace.UpdateOrderStateRequest.order_id_)
  return _impl_.order_id__.Release();
}
inline void UpdateOrderStateRequest::set_allocated_order_id_(std::string* order_id_) {
  if (order_id_ != nullptr) {
    
  } else {
    
  }
  _impl_.order_id__.SetAllocated(order_id_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.order_id__.IsDefault()) {
    _impl_.order_id__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:userspace.UpdateOrderStateRequest.order_id_)
}

// string order_status_ = 2;
inline void UpdateOrderStateRequest::clear_order_status_() {
  _impl_.order_status__.ClearToEmpty();
}
inline const std::string& UpdateOrderStateRequest::order_status_() const {
  // @@protoc_insertion_point(field_get:userspace.UpdateOrderStateRequest.order_status_)
  return _internal_order_status_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateOrderStateRequest::set_order_status_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.order_status__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:userspace.UpdateOrderStateRequest.order_status_)
}
inline std::string* UpdateOrderStateRequest::mutable_order_status_() {
  std::string* _s = _internal_mutable_order_status_();
  // @@protoc_insertion_point(field_mutable:userspace.UpdateOrderStateRequest.order_status_)
  return _s;
}
inline const std::string& UpdateOrderStateRequest::_internal_order_status_() const {
  return _impl_.order_status__.Get();
}
inline void UpdateOrderStateRequest::_internal_set_order_status_(const std::string& value) {
  
  _impl_.order_status__.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateOrderStateRequest::_internal_mutable_order_status_() {
  
  return _impl_.order_status__.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateOrderStateRequest::release_order_status_() {
  // @@protoc_insertion_point(field_release:userspace.UpdateOrderStateRequest.order_status_)
  return _impl_.order_status__.Release();
}
inline void UpdateOrderStateRequest::set_allocated_order_status_(std::string* order_status_) {
  if (order_status_ != nullptr) {
    
  } else {
    
  }
  _impl_.order_status__.SetAllocated(order_status_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.order_status__.IsDefault()) {
    _impl_.order_status__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:userspace.UpdateOrderStateRequest.order_status_)
}

// -------------------------------------------------------------------

// BaseReply

// bool return_result_ = 1;
inline void BaseReply::clear_return_result_() {
  _impl_.return_result__ = false;
}
inline bool BaseReply::_internal_return_result_() const {
  return _impl_.return_result__;
}
inline bool BaseReply::return_result_() const {
  // @@protoc_insertion_point(field_get:userspace.BaseReply.return_result_)
  return _internal_return_result_();
}
inline void BaseReply::_internal_set_return_result_(bool value) {
  
  _impl_.return_result__ = value;
}
inline void BaseReply::set_return_result_(bool value) {
  _internal_set_return_result_(value);
  // @@protoc_insertion_point(field_set:userspace.BaseReply.return_result_)
}

// string return_message_ = 2;
inline void BaseReply::clear_return_message_() {
  _impl_.return_message__.ClearToEmpty();
}
inline const std::string& BaseReply::return_message_() const {
  // @@protoc_insertion_point(field_get:userspace.BaseReply.return_message_)
  return _internal_return_message_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BaseReply::set_return_message_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.return_message__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:userspace.BaseReply.return_message_)
}
inline std::string* BaseReply::mutable_return_message_() {
  std::string* _s = _internal_mutable_return_message_();
  // @@protoc_insertion_point(field_mutable:userspace.BaseReply.return_message_)
  return _s;
}
inline const std::string& BaseReply::_internal_return_message_() const {
  return _impl_.return_message__.Get();
}
inline void BaseReply::_internal_set_return_message_(const std::string& value) {
  
  _impl_.return_message__.Set(value, GetArenaForAllocation());
}
inline std::string* BaseReply::_internal_mutable_return_message_() {
  
  return _impl_.return_message__.Mutable(GetArenaForAllocation());
}
inline std::string* BaseReply::release_return_message_() {
  // @@protoc_insertion_point(field_release:userspace.BaseReply.return_message_)
  return _impl_.return_message__.Release();
}
inline void BaseReply::set_allocated_return_message_(std::string* return_message_) {
  if (return_message_ != nullptr) {
    
  } else {
    
  }
  _impl_.return_message__.SetAllocated(return_message_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.return_message__.IsDefault()) {
    _impl_.return_message__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:userspace.BaseReply.return_message_)
}

// -------------------------------------------------------------------

// OrderId

// string order_id_ = 1;
inline void OrderId::clear_order_id_() {
  _impl_.order_id__.ClearToEmpty();
}
inline const std::string& OrderId::order_id_() const {
  // @@protoc_insertion_point(field_get:userspace.OrderId.order_id_)
  return _internal_order_id_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderId::set_order_id_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.order_id__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:userspace.OrderId.order_id_)
}
inline std::string* OrderId::mutable_order_id_() {
  std::string* _s = _internal_mutable_order_id_();
  // @@protoc_insertion_point(field_mutable:userspace.OrderId.order_id_)
  return _s;
}
inline const std::string& OrderId::_internal_order_id_() const {
  return _impl_.order_id__.Get();
}
inline void OrderId::_internal_set_order_id_(const std::string& value) {
  
  _impl_.order_id__.Set(value, GetArenaForAllocation());
}
inline std::string* OrderId::_internal_mutable_order_id_() {
  
  return _impl_.order_id__.Mutable(GetArenaForAllocation());
}
inline std::string* OrderId::release_order_id_() {
  // @@protoc_insertion_point(field_release:userspace.OrderId.order_id_)
  return _impl_.order_id__.Release();
}
inline void OrderId::set_allocated_order_id_(std::string* order_id_) {
  if (order_id_ != nullptr) {
    
  } else {
    
  }
  _impl_.order_id__.SetAllocated(order_id_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.order_id__.IsDefault()) {
    _impl_.order_id__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:userspace.OrderId.order_id_)
}

// -------------------------------------------------------------------

// OrderTransport

// string transport_time_ = 1;
inline void OrderTransport::clear_transport_time_() {
  _impl_.transport_time__.ClearToEmpty();
}
inline const std::string& OrderTransport::transport_time_() const {
  // @@protoc_insertion_point(field_get:userspace.OrderTransport.transport_time_)
  return _internal_transport_time_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderTransport::set_transport_time_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.transport_time__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:userspace.OrderTransport.transport_time_)
}
inline std::string* OrderTransport::mutable_transport_time_() {
  std::string* _s = _internal_mutable_transport_time_();
  // @@protoc_insertion_point(field_mutable:userspace.OrderTransport.transport_time_)
  return _s;
}
inline const std::string& OrderTransport::_internal_transport_time_() const {
  return _impl_.transport_time__.Get();
}
inline void OrderTransport::_internal_set_transport_time_(const std::string& value) {
  
  _impl_.transport_time__.Set(value, GetArenaForAllocation());
}
inline std::string* OrderTransport::_internal_mutable_transport_time_() {
  
  return _impl_.transport_time__.Mutable(GetArenaForAllocation());
}
inline std::string* OrderTransport::release_transport_time_() {
  // @@protoc_insertion_point(field_release:userspace.OrderTransport.transport_time_)
  return _impl_.transport_time__.Release();
}
inline void OrderTransport::set_allocated_transport_time_(std::string* transport_time_) {
  if (transport_time_ != nullptr) {
    
  } else {
    
  }
  _impl_.transport_time__.SetAllocated(transport_time_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.transport_time__.IsDefault()) {
    _impl_.transport_time__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:userspace.OrderTransport.transport_time_)
}

// string transport_description_ = 2;
inline void OrderTransport::clear_transport_description_() {
  _impl_.transport_description__.ClearToEmpty();
}
inline const std::string& OrderTransport::transport_description_() const {
  // @@protoc_insertion_point(field_get:userspace.OrderTransport.transport_description_)
  return _internal_transport_description_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderTransport::set_transport_description_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.transport_description__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:userspace.OrderTransport.transport_description_)
}
inline std::string* OrderTransport::mutable_transport_description_() {
  std::string* _s = _internal_mutable_transport_description_();
  // @@protoc_insertion_point(field_mutable:userspace.OrderTransport.transport_description_)
  return _s;
}
inline const std::string& OrderTransport::_internal_transport_description_() const {
  return _impl_.transport_description__.Get();
}
inline void OrderTransport::_internal_set_transport_description_(const std::string& value) {
  
  _impl_.transport_description__.Set(value, GetArenaForAllocation());
}
inline std::string* OrderTransport::_internal_mutable_transport_description_() {
  
  return _impl_.transport_description__.Mutable(GetArenaForAllocation());
}
inline std::string* OrderTransport::release_transport_description_() {
  // @@protoc_insertion_point(field_release:userspace.OrderTransport.transport_description_)
  return _impl_.transport_description__.Release();
}
inline void OrderTransport::set_allocated_transport_description_(std::string* transport_description_) {
  if (transport_description_ != nullptr) {
    
  } else {
    
  }
  _impl_.transport_description__.SetAllocated(transport_description_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.transport_description__.IsDefault()) {
    _impl_.transport_description__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:userspace.OrderTransport.transport_description_)
}

// -------------------------------------------------------------------

// SpecificOrder

// bool return_result_ = 1;
inline void SpecificOrder::clear_return_result_() {
  _impl_.return_result__ = false;
}
inline bool SpecificOrder::_internal_return_result_() const {
  return _impl_.return_result__;
}
inline bool SpecificOrder::return_result_() const {
  // @@protoc_insertion_point(field_get:userspace.SpecificOrder.return_result_)
  return _internal_return_result_();
}
inline void SpecificOrder::_internal_set_return_result_(bool value) {
  
  _impl_.return_result__ = value;
}
inline void SpecificOrder::set_return_result_(bool value) {
  _internal_set_return_result_(value);
  // @@protoc_insertion_point(field_set:userspace.SpecificOrder.return_result_)
}

// string return_message_ = 2;
inline void SpecificOrder::clear_return_message_() {
  _impl_.return_message__.ClearToEmpty();
}
inline const std::string& SpecificOrder::return_message_() const {
  // @@protoc_insertion_point(field_get:userspace.SpecificOrder.return_message_)
  return _internal_return_message_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpecificOrder::set_return_message_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.return_message__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:userspace.SpecificOrder.return_message_)
}
inline std::string* SpecificOrder::mutable_return_message_() {
  std::string* _s = _internal_mutable_return_message_();
  // @@protoc_insertion_point(field_mutable:userspace.SpecificOrder.return_message_)
  return _s;
}
inline const std::string& SpecificOrder::_internal_return_message_() const {
  return _impl_.return_message__.Get();
}
inline void SpecificOrder::_internal_set_return_message_(const std::string& value) {
  
  _impl_.return_message__.Set(value, GetArenaForAllocation());
}
inline std::string* SpecificOrder::_internal_mutable_return_message_() {
  
  return _impl_.return_message__.Mutable(GetArenaForAllocation());
}
inline std::string* SpecificOrder::release_return_message_() {
  // @@protoc_insertion_point(field_release:userspace.SpecificOrder.return_message_)
  return _impl_.return_message__.Release();
}
inline void SpecificOrder::set_allocated_return_message_(std::string* return_message_) {
  if (return_message_ != nullptr) {
    
  } else {
    
  }
  _impl_.return_message__.SetAllocated(return_message_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.return_message__.IsDefault()) {
    _impl_.return_message__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:userspace.SpecificOrder.return_message_)
}

// repeated .userspace.OrderTransport transport_list_ = 3;
inline int SpecificOrder::_internal_transport_list__size() const {
  return _impl_.transport_list__.size();
}
inline int SpecificOrder::transport_list__size() const {
  return _internal_transport_list__size();
}
inline void SpecificOrder::clear_transport_list_() {
  _impl_.transport_list__.Clear();
}
inline ::userspace::OrderTransport* SpecificOrder::mutable_transport_list_(int index) {
  // @@protoc_insertion_point(field_mutable:userspace.SpecificOrder.transport_list_)
  return _impl_.transport_list__.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::userspace::OrderTransport >*
SpecificOrder::mutable_transport_list_() {
  // @@protoc_insertion_point(field_mutable_list:userspace.SpecificOrder.transport_list_)
  return &_impl_.transport_list__;
}
inline const ::userspace::OrderTransport& SpecificOrder::_internal_transport_list_(int index) const {
  return _impl_.transport_list__.Get(index);
}
inline const ::userspace::OrderTransport& SpecificOrder::transport_list_(int index) const {
  // @@protoc_insertion_point(field_get:userspace.SpecificOrder.transport_list_)
  return _internal_transport_list_(index);
}
inline ::userspace::OrderTransport* SpecificOrder::_internal_add_transport_list_() {
  return _impl_.transport_list__.Add();
}
inline ::userspace::OrderTransport* SpecificOrder::add_transport_list_() {
  ::userspace::OrderTransport* _add = _internal_add_transport_list_();
  // @@protoc_insertion_point(field_add:userspace.SpecificOrder.transport_list_)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::userspace::OrderTransport >&
SpecificOrder::transport_list_() const {
  // @@protoc_insertion_point(field_list:userspace.SpecificOrder.transport_list_)
  return _impl_.transport_list__;
}

// repeated .userspace.OrderItem item_list_ = 4;
inline int SpecificOrder::_internal_item_list__size() const {
  return _impl_.item_list__.size();
}
inline int SpecificOrder::item_list__size() const {
  return _internal_item_list__size();
}
inline void SpecificOrder::clear_item_list_() {
  _impl_.item_list__.Clear();
}
inline ::userspace::OrderItem* SpecificOrder::mutable_item_list_(int index) {
  // @@protoc_insertion_point(field_mutable:userspace.SpecificOrder.item_list_)
  return _impl_.item_list__.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::userspace::OrderItem >*
SpecificOrder::mutable_item_list_() {
  // @@protoc_insertion_point(field_mutable_list:userspace.SpecificOrder.item_list_)
  return &_impl_.item_list__;
}
inline const ::userspace::OrderItem& SpecificOrder::_internal_item_list_(int index) const {
  return _impl_.item_list__.Get(index);
}
inline const ::userspace::OrderItem& SpecificOrder::item_list_(int index) const {
  // @@protoc_insertion_point(field_get:userspace.SpecificOrder.item_list_)
  return _internal_item_list_(index);
}
inline ::userspace::OrderItem* SpecificOrder::_internal_add_item_list_() {
  return _impl_.item_list__.Add();
}
inline ::userspace::OrderItem* SpecificOrder::add_item_list_() {
  ::userspace::OrderItem* _add = _internal_add_item_list_();
  // @@protoc_insertion_point(field_add:userspace.SpecificOrder.item_list_)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::userspace::OrderItem >&
SpecificOrder::item_list_() const {
  // @@protoc_insertion_point(field_list:userspace.SpecificOrder.item_list_)
  return _impl_.item_list__;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace userspace

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_myuser_2eproto
