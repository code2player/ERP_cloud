// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mystationer.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_mystationer_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_mystationer_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_mystationer_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_mystationer_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_mystationer_2eproto;
namespace stationerspace {
class BaseReply2;
struct BaseReply2DefaultTypeInternal;
extern BaseReply2DefaultTypeInternal _BaseReply2_default_instance_;
class InStationRequest;
struct InStationRequestDefaultTypeInternal;
extern InStationRequestDefaultTypeInternal _InStationRequest_default_instance_;
class OutStationRequest;
struct OutStationRequestDefaultTypeInternal;
extern OutStationRequestDefaultTypeInternal _OutStationRequest_default_instance_;
class SaveOrder;
struct SaveOrderDefaultTypeInternal;
extern SaveOrderDefaultTypeInternal _SaveOrder_default_instance_;
class SaveOrderList;
struct SaveOrderListDefaultTypeInternal;
extern SaveOrderListDefaultTypeInternal _SaveOrderList_default_instance_;
class StationId;
struct StationIdDefaultTypeInternal;
extern StationIdDefaultTypeInternal _StationId_default_instance_;
class StationerId;
struct StationerIdDefaultTypeInternal;
extern StationerIdDefaultTypeInternal _StationerId_default_instance_;
class StationerInfo;
struct StationerInfoDefaultTypeInternal;
extern StationerInfoDefaultTypeInternal _StationerInfo_default_instance_;
}  // namespace stationerspace
PROTOBUF_NAMESPACE_OPEN
template<> ::stationerspace::BaseReply2* Arena::CreateMaybeMessage<::stationerspace::BaseReply2>(Arena*);
template<> ::stationerspace::InStationRequest* Arena::CreateMaybeMessage<::stationerspace::InStationRequest>(Arena*);
template<> ::stationerspace::OutStationRequest* Arena::CreateMaybeMessage<::stationerspace::OutStationRequest>(Arena*);
template<> ::stationerspace::SaveOrder* Arena::CreateMaybeMessage<::stationerspace::SaveOrder>(Arena*);
template<> ::stationerspace::SaveOrderList* Arena::CreateMaybeMessage<::stationerspace::SaveOrderList>(Arena*);
template<> ::stationerspace::StationId* Arena::CreateMaybeMessage<::stationerspace::StationId>(Arena*);
template<> ::stationerspace::StationerId* Arena::CreateMaybeMessage<::stationerspace::StationerId>(Arena*);
template<> ::stationerspace::StationerInfo* Arena::CreateMaybeMessage<::stationerspace::StationerInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace stationerspace {

// ===================================================================

class StationerId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:stationerspace.StationerId) */ {
 public:
  inline StationerId() : StationerId(nullptr) {}
  ~StationerId() override;
  explicit PROTOBUF_CONSTEXPR StationerId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StationerId(const StationerId& from);
  StationerId(StationerId&& from) noexcept
    : StationerId() {
    *this = ::std::move(from);
  }

  inline StationerId& operator=(const StationerId& from) {
    CopyFrom(from);
    return *this;
  }
  inline StationerId& operator=(StationerId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StationerId& default_instance() {
    return *internal_default_instance();
  }
  static inline const StationerId* internal_default_instance() {
    return reinterpret_cast<const StationerId*>(
               &_StationerId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(StationerId& a, StationerId& b) {
    a.Swap(&b);
  }
  inline void Swap(StationerId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StationerId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StationerId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StationerId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StationerId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StationerId& from) {
    StationerId::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StationerId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "stationerspace.StationerId";
  }
  protected:
  explicit StationerId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStationerIdFieldNumber = 1,
  };
  // string stationer_id_ = 1;
  void clear_stationer_id_();
  const std::string& stationer_id_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stationer_id_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stationer_id_();
  PROTOBUF_NODISCARD std::string* release_stationer_id_();
  void set_allocated_stationer_id_(std::string* stationer_id_);
  private:
  const std::string& _internal_stationer_id_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stationer_id_(const std::string& value);
  std::string* _internal_mutable_stationer_id_();
  public:

  // @@protoc_insertion_point(class_scope:stationerspace.StationerId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stationer_id__;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mystationer_2eproto;
};
// -------------------------------------------------------------------

class BaseReply2 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:stationerspace.BaseReply2) */ {
 public:
  inline BaseReply2() : BaseReply2(nullptr) {}
  ~BaseReply2() override;
  explicit PROTOBUF_CONSTEXPR BaseReply2(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BaseReply2(const BaseReply2& from);
  BaseReply2(BaseReply2&& from) noexcept
    : BaseReply2() {
    *this = ::std::move(from);
  }

  inline BaseReply2& operator=(const BaseReply2& from) {
    CopyFrom(from);
    return *this;
  }
  inline BaseReply2& operator=(BaseReply2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BaseReply2& default_instance() {
    return *internal_default_instance();
  }
  static inline const BaseReply2* internal_default_instance() {
    return reinterpret_cast<const BaseReply2*>(
               &_BaseReply2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(BaseReply2& a, BaseReply2& b) {
    a.Swap(&b);
  }
  inline void Swap(BaseReply2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BaseReply2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BaseReply2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BaseReply2>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BaseReply2& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BaseReply2& from) {
    BaseReply2::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BaseReply2* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "stationerspace.BaseReply2";
  }
  protected:
  explicit BaseReply2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReturnMessageFieldNumber = 2,
    kReturnResultFieldNumber = 1,
  };
  // string return_message_ = 2;
  void clear_return_message_();
  const std::string& return_message_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_return_message_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_return_message_();
  PROTOBUF_NODISCARD std::string* release_return_message_();
  void set_allocated_return_message_(std::string* return_message_);
  private:
  const std::string& _internal_return_message_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_return_message_(const std::string& value);
  std::string* _internal_mutable_return_message_();
  public:

  // bool return_result_ = 1;
  void clear_return_result_();
  bool return_result_() const;
  void set_return_result_(bool value);
  private:
  bool _internal_return_result_() const;
  void _internal_set_return_result_(bool value);
  public:

  // @@protoc_insertion_point(class_scope:stationerspace.BaseReply2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr return_message__;
    bool return_result__;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mystationer_2eproto;
};
// -------------------------------------------------------------------

class StationId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:stationerspace.StationId) */ {
 public:
  inline StationId() : StationId(nullptr) {}
  ~StationId() override;
  explicit PROTOBUF_CONSTEXPR StationId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StationId(const StationId& from);
  StationId(StationId&& from) noexcept
    : StationId() {
    *this = ::std::move(from);
  }

  inline StationId& operator=(const StationId& from) {
    CopyFrom(from);
    return *this;
  }
  inline StationId& operator=(StationId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StationId& default_instance() {
    return *internal_default_instance();
  }
  static inline const StationId* internal_default_instance() {
    return reinterpret_cast<const StationId*>(
               &_StationId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(StationId& a, StationId& b) {
    a.Swap(&b);
  }
  inline void Swap(StationId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StationId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StationId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StationId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StationId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StationId& from) {
    StationId::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StationId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "stationerspace.StationId";
  }
  protected:
  explicit StationId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStationIdFieldNumber = 1,
  };
  // string station_id_ = 1;
  void clear_station_id_();
  const std::string& station_id_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_station_id_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_station_id_();
  PROTOBUF_NODISCARD std::string* release_station_id_();
  void set_allocated_station_id_(std::string* station_id_);
  private:
  const std::string& _internal_station_id_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_station_id_(const std::string& value);
  std::string* _internal_mutable_station_id_();
  public:

  // @@protoc_insertion_point(class_scope:stationerspace.StationId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr station_id__;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mystationer_2eproto;
};
// -------------------------------------------------------------------

class SaveOrder final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:stationerspace.SaveOrder) */ {
 public:
  inline SaveOrder() : SaveOrder(nullptr) {}
  ~SaveOrder() override;
  explicit PROTOBUF_CONSTEXPR SaveOrder(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SaveOrder(const SaveOrder& from);
  SaveOrder(SaveOrder&& from) noexcept
    : SaveOrder() {
    *this = ::std::move(from);
  }

  inline SaveOrder& operator=(const SaveOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline SaveOrder& operator=(SaveOrder&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SaveOrder& default_instance() {
    return *internal_default_instance();
  }
  static inline const SaveOrder* internal_default_instance() {
    return reinterpret_cast<const SaveOrder*>(
               &_SaveOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SaveOrder& a, SaveOrder& b) {
    a.Swap(&b);
  }
  inline void Swap(SaveOrder* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SaveOrder* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SaveOrder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SaveOrder>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SaveOrder& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SaveOrder& from) {
    SaveOrder::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SaveOrder* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "stationerspace.SaveOrder";
  }
  protected:
  explicit SaveOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderIdFieldNumber = 1,
    kInputTimeFieldNumber = 2,
  };
  // string order_id_ = 1;
  void clear_order_id_();
  const std::string& order_id_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_order_id_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_order_id_();
  PROTOBUF_NODISCARD std::string* release_order_id_();
  void set_allocated_order_id_(std::string* order_id_);
  private:
  const std::string& _internal_order_id_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_id_(const std::string& value);
  std::string* _internal_mutable_order_id_();
  public:

  // string input_time_ = 2;
  void clear_input_time_();
  const std::string& input_time_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_input_time_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_input_time_();
  PROTOBUF_NODISCARD std::string* release_input_time_();
  void set_allocated_input_time_(std::string* input_time_);
  private:
  const std::string& _internal_input_time_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_input_time_(const std::string& value);
  std::string* _internal_mutable_input_time_();
  public:

  // @@protoc_insertion_point(class_scope:stationerspace.SaveOrder)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_id__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr input_time__;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mystationer_2eproto;
};
// -------------------------------------------------------------------

class SaveOrderList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:stationerspace.SaveOrderList) */ {
 public:
  inline SaveOrderList() : SaveOrderList(nullptr) {}
  ~SaveOrderList() override;
  explicit PROTOBUF_CONSTEXPR SaveOrderList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SaveOrderList(const SaveOrderList& from);
  SaveOrderList(SaveOrderList&& from) noexcept
    : SaveOrderList() {
    *this = ::std::move(from);
  }

  inline SaveOrderList& operator=(const SaveOrderList& from) {
    CopyFrom(from);
    return *this;
  }
  inline SaveOrderList& operator=(SaveOrderList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SaveOrderList& default_instance() {
    return *internal_default_instance();
  }
  static inline const SaveOrderList* internal_default_instance() {
    return reinterpret_cast<const SaveOrderList*>(
               &_SaveOrderList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SaveOrderList& a, SaveOrderList& b) {
    a.Swap(&b);
  }
  inline void Swap(SaveOrderList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SaveOrderList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SaveOrderList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SaveOrderList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SaveOrderList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SaveOrderList& from) {
    SaveOrderList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SaveOrderList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "stationerspace.SaveOrderList";
  }
  protected:
  explicit SaveOrderList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderListFieldNumber = 3,
    kReturnMessageFieldNumber = 2,
    kReturnResultFieldNumber = 1,
  };
  // repeated .stationerspace.SaveOrder order_list_ = 3;
  int order_list__size() const;
  private:
  int _internal_order_list__size() const;
  public:
  void clear_order_list_();
  ::stationerspace::SaveOrder* mutable_order_list_(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stationerspace::SaveOrder >*
      mutable_order_list_();
  private:
  const ::stationerspace::SaveOrder& _internal_order_list_(int index) const;
  ::stationerspace::SaveOrder* _internal_add_order_list_();
  public:
  const ::stationerspace::SaveOrder& order_list_(int index) const;
  ::stationerspace::SaveOrder* add_order_list_();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stationerspace::SaveOrder >&
      order_list_() const;

  // string return_message_ = 2;
  void clear_return_message_();
  const std::string& return_message_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_return_message_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_return_message_();
  PROTOBUF_NODISCARD std::string* release_return_message_();
  void set_allocated_return_message_(std::string* return_message_);
  private:
  const std::string& _internal_return_message_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_return_message_(const std::string& value);
  std::string* _internal_mutable_return_message_();
  public:

  // bool return_result_ = 1;
  void clear_return_result_();
  bool return_result_() const;
  void set_return_result_(bool value);
  private:
  bool _internal_return_result_() const;
  void _internal_set_return_result_(bool value);
  public:

  // @@protoc_insertion_point(class_scope:stationerspace.SaveOrderList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stationerspace::SaveOrder > order_list__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr return_message__;
    bool return_result__;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mystationer_2eproto;
};
// -------------------------------------------------------------------

class InStationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:stationerspace.InStationRequest) */ {
 public:
  inline InStationRequest() : InStationRequest(nullptr) {}
  ~InStationRequest() override;
  explicit PROTOBUF_CONSTEXPR InStationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InStationRequest(const InStationRequest& from);
  InStationRequest(InStationRequest&& from) noexcept
    : InStationRequest() {
    *this = ::std::move(from);
  }

  inline InStationRequest& operator=(const InStationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InStationRequest& operator=(InStationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InStationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InStationRequest* internal_default_instance() {
    return reinterpret_cast<const InStationRequest*>(
               &_InStationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(InStationRequest& a, InStationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InStationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InStationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InStationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InStationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InStationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InStationRequest& from) {
    InStationRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InStationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "stationerspace.InStationRequest";
  }
  protected:
  explicit InStationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStationerIdFieldNumber = 1,
    kOrderIdFieldNumber = 2,
    kStationIdFieldNumber = 3,
  };
  // string stationer_id_ = 1;
  void clear_stationer_id_();
  const std::string& stationer_id_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stationer_id_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stationer_id_();
  PROTOBUF_NODISCARD std::string* release_stationer_id_();
  void set_allocated_stationer_id_(std::string* stationer_id_);
  private:
  const std::string& _internal_stationer_id_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stationer_id_(const std::string& value);
  std::string* _internal_mutable_stationer_id_();
  public:

  // string order_id_ = 2;
  void clear_order_id_();
  const std::string& order_id_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_order_id_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_order_id_();
  PROTOBUF_NODISCARD std::string* release_order_id_();
  void set_allocated_order_id_(std::string* order_id_);
  private:
  const std::string& _internal_order_id_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_id_(const std::string& value);
  std::string* _internal_mutable_order_id_();
  public:

  // string station_id_ = 3;
  void clear_station_id_();
  const std::string& station_id_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_station_id_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_station_id_();
  PROTOBUF_NODISCARD std::string* release_station_id_();
  void set_allocated_station_id_(std::string* station_id_);
  private:
  const std::string& _internal_station_id_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_station_id_(const std::string& value);
  std::string* _internal_mutable_station_id_();
  public:

  // @@protoc_insertion_point(class_scope:stationerspace.InStationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stationer_id__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_id__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr station_id__;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mystationer_2eproto;
};
// -------------------------------------------------------------------

class OutStationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:stationerspace.OutStationRequest) */ {
 public:
  inline OutStationRequest() : OutStationRequest(nullptr) {}
  ~OutStationRequest() override;
  explicit PROTOBUF_CONSTEXPR OutStationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OutStationRequest(const OutStationRequest& from);
  OutStationRequest(OutStationRequest&& from) noexcept
    : OutStationRequest() {
    *this = ::std::move(from);
  }

  inline OutStationRequest& operator=(const OutStationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline OutStationRequest& operator=(OutStationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OutStationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const OutStationRequest* internal_default_instance() {
    return reinterpret_cast<const OutStationRequest*>(
               &_OutStationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(OutStationRequest& a, OutStationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(OutStationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OutStationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OutStationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OutStationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OutStationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OutStationRequest& from) {
    OutStationRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OutStationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "stationerspace.OutStationRequest";
  }
  protected:
  explicit OutStationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStationerIdFieldNumber = 1,
    kOrderIdFieldNumber = 2,
    kStationIdFieldNumber = 3,
    kNextAddressFieldNumber = 4,
  };
  // string stationer_id_ = 1;
  void clear_stationer_id_();
  const std::string& stationer_id_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stationer_id_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stationer_id_();
  PROTOBUF_NODISCARD std::string* release_stationer_id_();
  void set_allocated_stationer_id_(std::string* stationer_id_);
  private:
  const std::string& _internal_stationer_id_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stationer_id_(const std::string& value);
  std::string* _internal_mutable_stationer_id_();
  public:

  // string order_id_ = 2;
  void clear_order_id_();
  const std::string& order_id_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_order_id_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_order_id_();
  PROTOBUF_NODISCARD std::string* release_order_id_();
  void set_allocated_order_id_(std::string* order_id_);
  private:
  const std::string& _internal_order_id_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_id_(const std::string& value);
  std::string* _internal_mutable_order_id_();
  public:

  // string station_id_ = 3;
  void clear_station_id_();
  const std::string& station_id_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_station_id_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_station_id_();
  PROTOBUF_NODISCARD std::string* release_station_id_();
  void set_allocated_station_id_(std::string* station_id_);
  private:
  const std::string& _internal_station_id_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_station_id_(const std::string& value);
  std::string* _internal_mutable_station_id_();
  public:

  // string next_address_ = 4;
  void clear_next_address_();
  const std::string& next_address_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_address_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_address_();
  PROTOBUF_NODISCARD std::string* release_next_address_();
  void set_allocated_next_address_(std::string* next_address_);
  private:
  const std::string& _internal_next_address_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_address_(const std::string& value);
  std::string* _internal_mutable_next_address_();
  public:

  // @@protoc_insertion_point(class_scope:stationerspace.OutStationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stationer_id__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_id__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr station_id__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_address__;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mystationer_2eproto;
};
// -------------------------------------------------------------------

class StationerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:stationerspace.StationerInfo) */ {
 public:
  inline StationerInfo() : StationerInfo(nullptr) {}
  ~StationerInfo() override;
  explicit PROTOBUF_CONSTEXPR StationerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StationerInfo(const StationerInfo& from);
  StationerInfo(StationerInfo&& from) noexcept
    : StationerInfo() {
    *this = ::std::move(from);
  }

  inline StationerInfo& operator=(const StationerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline StationerInfo& operator=(StationerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StationerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const StationerInfo* internal_default_instance() {
    return reinterpret_cast<const StationerInfo*>(
               &_StationerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(StationerInfo& a, StationerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(StationerInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StationerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StationerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StationerInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StationerInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StationerInfo& from) {
    StationerInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StationerInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "stationerspace.StationerInfo";
  }
  protected:
  explicit StationerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReturnMessageFieldNumber = 2,
    kStationerIdFieldNumber = 3,
    kStationIdFieldNumber = 4,
    kStationerNameFieldNumber = 5,
    kReturnResultFieldNumber = 1,
  };
  // string return_message_ = 2;
  void clear_return_message_();
  const std::string& return_message_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_return_message_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_return_message_();
  PROTOBUF_NODISCARD std::string* release_return_message_();
  void set_allocated_return_message_(std::string* return_message_);
  private:
  const std::string& _internal_return_message_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_return_message_(const std::string& value);
  std::string* _internal_mutable_return_message_();
  public:

  // string stationer_id_ = 3;
  void clear_stationer_id_();
  const std::string& stationer_id_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stationer_id_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stationer_id_();
  PROTOBUF_NODISCARD std::string* release_stationer_id_();
  void set_allocated_stationer_id_(std::string* stationer_id_);
  private:
  const std::string& _internal_stationer_id_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stationer_id_(const std::string& value);
  std::string* _internal_mutable_stationer_id_();
  public:

  // string station_id_ = 4;
  void clear_station_id_();
  const std::string& station_id_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_station_id_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_station_id_();
  PROTOBUF_NODISCARD std::string* release_station_id_();
  void set_allocated_station_id_(std::string* station_id_);
  private:
  const std::string& _internal_station_id_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_station_id_(const std::string& value);
  std::string* _internal_mutable_station_id_();
  public:

  // string stationer_name = 5;
  void clear_stationer_name();
  const std::string& stationer_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stationer_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stationer_name();
  PROTOBUF_NODISCARD std::string* release_stationer_name();
  void set_allocated_stationer_name(std::string* stationer_name);
  private:
  const std::string& _internal_stationer_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stationer_name(const std::string& value);
  std::string* _internal_mutable_stationer_name();
  public:

  // bool return_result_ = 1;
  void clear_return_result_();
  bool return_result_() const;
  void set_return_result_(bool value);
  private:
  bool _internal_return_result_() const;
  void _internal_set_return_result_(bool value);
  public:

  // @@protoc_insertion_point(class_scope:stationerspace.StationerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr return_message__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stationer_id__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr station_id__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stationer_name_;
    bool return_result__;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mystationer_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// StationerId

// string stationer_id_ = 1;
inline void StationerId::clear_stationer_id_() {
  _impl_.stationer_id__.ClearToEmpty();
}
inline const std::string& StationerId::stationer_id_() const {
  // @@protoc_insertion_point(field_get:stationerspace.StationerId.stationer_id_)
  return _internal_stationer_id_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StationerId::set_stationer_id_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.stationer_id__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:stationerspace.StationerId.stationer_id_)
}
inline std::string* StationerId::mutable_stationer_id_() {
  std::string* _s = _internal_mutable_stationer_id_();
  // @@protoc_insertion_point(field_mutable:stationerspace.StationerId.stationer_id_)
  return _s;
}
inline const std::string& StationerId::_internal_stationer_id_() const {
  return _impl_.stationer_id__.Get();
}
inline void StationerId::_internal_set_stationer_id_(const std::string& value) {
  
  _impl_.stationer_id__.Set(value, GetArenaForAllocation());
}
inline std::string* StationerId::_internal_mutable_stationer_id_() {
  
  return _impl_.stationer_id__.Mutable(GetArenaForAllocation());
}
inline std::string* StationerId::release_stationer_id_() {
  // @@protoc_insertion_point(field_release:stationerspace.StationerId.stationer_id_)
  return _impl_.stationer_id__.Release();
}
inline void StationerId::set_allocated_stationer_id_(std::string* stationer_id_) {
  if (stationer_id_ != nullptr) {
    
  } else {
    
  }
  _impl_.stationer_id__.SetAllocated(stationer_id_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stationer_id__.IsDefault()) {
    _impl_.stationer_id__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:stationerspace.StationerId.stationer_id_)
}

// -------------------------------------------------------------------

// BaseReply2

// bool return_result_ = 1;
inline void BaseReply2::clear_return_result_() {
  _impl_.return_result__ = false;
}
inline bool BaseReply2::_internal_return_result_() const {
  return _impl_.return_result__;
}
inline bool BaseReply2::return_result_() const {
  // @@protoc_insertion_point(field_get:stationerspace.BaseReply2.return_result_)
  return _internal_return_result_();
}
inline void BaseReply2::_internal_set_return_result_(bool value) {
  
  _impl_.return_result__ = value;
}
inline void BaseReply2::set_return_result_(bool value) {
  _internal_set_return_result_(value);
  // @@protoc_insertion_point(field_set:stationerspace.BaseReply2.return_result_)
}

// string return_message_ = 2;
inline void BaseReply2::clear_return_message_() {
  _impl_.return_message__.ClearToEmpty();
}
inline const std::string& BaseReply2::return_message_() const {
  // @@protoc_insertion_point(field_get:stationerspace.BaseReply2.return_message_)
  return _internal_return_message_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BaseReply2::set_return_message_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.return_message__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:stationerspace.BaseReply2.return_message_)
}
inline std::string* BaseReply2::mutable_return_message_() {
  std::string* _s = _internal_mutable_return_message_();
  // @@protoc_insertion_point(field_mutable:stationerspace.BaseReply2.return_message_)
  return _s;
}
inline const std::string& BaseReply2::_internal_return_message_() const {
  return _impl_.return_message__.Get();
}
inline void BaseReply2::_internal_set_return_message_(const std::string& value) {
  
  _impl_.return_message__.Set(value, GetArenaForAllocation());
}
inline std::string* BaseReply2::_internal_mutable_return_message_() {
  
  return _impl_.return_message__.Mutable(GetArenaForAllocation());
}
inline std::string* BaseReply2::release_return_message_() {
  // @@protoc_insertion_point(field_release:stationerspace.BaseReply2.return_message_)
  return _impl_.return_message__.Release();
}
inline void BaseReply2::set_allocated_return_message_(std::string* return_message_) {
  if (return_message_ != nullptr) {
    
  } else {
    
  }
  _impl_.return_message__.SetAllocated(return_message_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.return_message__.IsDefault()) {
    _impl_.return_message__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:stationerspace.BaseReply2.return_message_)
}

// -------------------------------------------------------------------

// StationId

// string station_id_ = 1;
inline void StationId::clear_station_id_() {
  _impl_.station_id__.ClearToEmpty();
}
inline const std::string& StationId::station_id_() const {
  // @@protoc_insertion_point(field_get:stationerspace.StationId.station_id_)
  return _internal_station_id_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StationId::set_station_id_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.station_id__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:stationerspace.StationId.station_id_)
}
inline std::string* StationId::mutable_station_id_() {
  std::string* _s = _internal_mutable_station_id_();
  // @@protoc_insertion_point(field_mutable:stationerspace.StationId.station_id_)
  return _s;
}
inline const std::string& StationId::_internal_station_id_() const {
  return _impl_.station_id__.Get();
}
inline void StationId::_internal_set_station_id_(const std::string& value) {
  
  _impl_.station_id__.Set(value, GetArenaForAllocation());
}
inline std::string* StationId::_internal_mutable_station_id_() {
  
  return _impl_.station_id__.Mutable(GetArenaForAllocation());
}
inline std::string* StationId::release_station_id_() {
  // @@protoc_insertion_point(field_release:stationerspace.StationId.station_id_)
  return _impl_.station_id__.Release();
}
inline void StationId::set_allocated_station_id_(std::string* station_id_) {
  if (station_id_ != nullptr) {
    
  } else {
    
  }
  _impl_.station_id__.SetAllocated(station_id_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.station_id__.IsDefault()) {
    _impl_.station_id__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:stationerspace.StationId.station_id_)
}

// -------------------------------------------------------------------

// SaveOrder

// string order_id_ = 1;
inline void SaveOrder::clear_order_id_() {
  _impl_.order_id__.ClearToEmpty();
}
inline const std::string& SaveOrder::order_id_() const {
  // @@protoc_insertion_point(field_get:stationerspace.SaveOrder.order_id_)
  return _internal_order_id_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SaveOrder::set_order_id_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.order_id__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:stationerspace.SaveOrder.order_id_)
}
inline std::string* SaveOrder::mutable_order_id_() {
  std::string* _s = _internal_mutable_order_id_();
  // @@protoc_insertion_point(field_mutable:stationerspace.SaveOrder.order_id_)
  return _s;
}
inline const std::string& SaveOrder::_internal_order_id_() const {
  return _impl_.order_id__.Get();
}
inline void SaveOrder::_internal_set_order_id_(const std::string& value) {
  
  _impl_.order_id__.Set(value, GetArenaForAllocation());
}
inline std::string* SaveOrder::_internal_mutable_order_id_() {
  
  return _impl_.order_id__.Mutable(GetArenaForAllocation());
}
inline std::string* SaveOrder::release_order_id_() {
  // @@protoc_insertion_point(field_release:stationerspace.SaveOrder.order_id_)
  return _impl_.order_id__.Release();
}
inline void SaveOrder::set_allocated_order_id_(std::string* order_id_) {
  if (order_id_ != nullptr) {
    
  } else {
    
  }
  _impl_.order_id__.SetAllocated(order_id_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.order_id__.IsDefault()) {
    _impl_.order_id__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:stationerspace.SaveOrder.order_id_)
}

// string input_time_ = 2;
inline void SaveOrder::clear_input_time_() {
  _impl_.input_time__.ClearToEmpty();
}
inline const std::string& SaveOrder::input_time_() const {
  // @@protoc_insertion_point(field_get:stationerspace.SaveOrder.input_time_)
  return _internal_input_time_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SaveOrder::set_input_time_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.input_time__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:stationerspace.SaveOrder.input_time_)
}
inline std::string* SaveOrder::mutable_input_time_() {
  std::string* _s = _internal_mutable_input_time_();
  // @@protoc_insertion_point(field_mutable:stationerspace.SaveOrder.input_time_)
  return _s;
}
inline const std::string& SaveOrder::_internal_input_time_() const {
  return _impl_.input_time__.Get();
}
inline void SaveOrder::_internal_set_input_time_(const std::string& value) {
  
  _impl_.input_time__.Set(value, GetArenaForAllocation());
}
inline std::string* SaveOrder::_internal_mutable_input_time_() {
  
  return _impl_.input_time__.Mutable(GetArenaForAllocation());
}
inline std::string* SaveOrder::release_input_time_() {
  // @@protoc_insertion_point(field_release:stationerspace.SaveOrder.input_time_)
  return _impl_.input_time__.Release();
}
inline void SaveOrder::set_allocated_input_time_(std::string* input_time_) {
  if (input_time_ != nullptr) {
    
  } else {
    
  }
  _impl_.input_time__.SetAllocated(input_time_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.input_time__.IsDefault()) {
    _impl_.input_time__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:stationerspace.SaveOrder.input_time_)
}

// -------------------------------------------------------------------

// SaveOrderList

// bool return_result_ = 1;
inline void SaveOrderList::clear_return_result_() {
  _impl_.return_result__ = false;
}
inline bool SaveOrderList::_internal_return_result_() const {
  return _impl_.return_result__;
}
inline bool SaveOrderList::return_result_() const {
  // @@protoc_insertion_point(field_get:stationerspace.SaveOrderList.return_result_)
  return _internal_return_result_();
}
inline void SaveOrderList::_internal_set_return_result_(bool value) {
  
  _impl_.return_result__ = value;
}
inline void SaveOrderList::set_return_result_(bool value) {
  _internal_set_return_result_(value);
  // @@protoc_insertion_point(field_set:stationerspace.SaveOrderList.return_result_)
}

// string return_message_ = 2;
inline void SaveOrderList::clear_return_message_() {
  _impl_.return_message__.ClearToEmpty();
}
inline const std::string& SaveOrderList::return_message_() const {
  // @@protoc_insertion_point(field_get:stationerspace.SaveOrderList.return_message_)
  return _internal_return_message_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SaveOrderList::set_return_message_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.return_message__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:stationerspace.SaveOrderList.return_message_)
}
inline std::string* SaveOrderList::mutable_return_message_() {
  std::string* _s = _internal_mutable_return_message_();
  // @@protoc_insertion_point(field_mutable:stationerspace.SaveOrderList.return_message_)
  return _s;
}
inline const std::string& SaveOrderList::_internal_return_message_() const {
  return _impl_.return_message__.Get();
}
inline void SaveOrderList::_internal_set_return_message_(const std::string& value) {
  
  _impl_.return_message__.Set(value, GetArenaForAllocation());
}
inline std::string* SaveOrderList::_internal_mutable_return_message_() {
  
  return _impl_.return_message__.Mutable(GetArenaForAllocation());
}
inline std::string* SaveOrderList::release_return_message_() {
  // @@protoc_insertion_point(field_release:stationerspace.SaveOrderList.return_message_)
  return _impl_.return_message__.Release();
}
inline void SaveOrderList::set_allocated_return_message_(std::string* return_message_) {
  if (return_message_ != nullptr) {
    
  } else {
    
  }
  _impl_.return_message__.SetAllocated(return_message_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.return_message__.IsDefault()) {
    _impl_.return_message__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:stationerspace.SaveOrderList.return_message_)
}

// repeated .stationerspace.SaveOrder order_list_ = 3;
inline int SaveOrderList::_internal_order_list__size() const {
  return _impl_.order_list__.size();
}
inline int SaveOrderList::order_list__size() const {
  return _internal_order_list__size();
}
inline void SaveOrderList::clear_order_list_() {
  _impl_.order_list__.Clear();
}
inline ::stationerspace::SaveOrder* SaveOrderList::mutable_order_list_(int index) {
  // @@protoc_insertion_point(field_mutable:stationerspace.SaveOrderList.order_list_)
  return _impl_.order_list__.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stationerspace::SaveOrder >*
SaveOrderList::mutable_order_list_() {
  // @@protoc_insertion_point(field_mutable_list:stationerspace.SaveOrderList.order_list_)
  return &_impl_.order_list__;
}
inline const ::stationerspace::SaveOrder& SaveOrderList::_internal_order_list_(int index) const {
  return _impl_.order_list__.Get(index);
}
inline const ::stationerspace::SaveOrder& SaveOrderList::order_list_(int index) const {
  // @@protoc_insertion_point(field_get:stationerspace.SaveOrderList.order_list_)
  return _internal_order_list_(index);
}
inline ::stationerspace::SaveOrder* SaveOrderList::_internal_add_order_list_() {
  return _impl_.order_list__.Add();
}
inline ::stationerspace::SaveOrder* SaveOrderList::add_order_list_() {
  ::stationerspace::SaveOrder* _add = _internal_add_order_list_();
  // @@protoc_insertion_point(field_add:stationerspace.SaveOrderList.order_list_)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stationerspace::SaveOrder >&
SaveOrderList::order_list_() const {
  // @@protoc_insertion_point(field_list:stationerspace.SaveOrderList.order_list_)
  return _impl_.order_list__;
}

// -------------------------------------------------------------------

// InStationRequest

// string stationer_id_ = 1;
inline void InStationRequest::clear_stationer_id_() {
  _impl_.stationer_id__.ClearToEmpty();
}
inline const std::string& InStationRequest::stationer_id_() const {
  // @@protoc_insertion_point(field_get:stationerspace.InStationRequest.stationer_id_)
  return _internal_stationer_id_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InStationRequest::set_stationer_id_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.stationer_id__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:stationerspace.InStationRequest.stationer_id_)
}
inline std::string* InStationRequest::mutable_stationer_id_() {
  std::string* _s = _internal_mutable_stationer_id_();
  // @@protoc_insertion_point(field_mutable:stationerspace.InStationRequest.stationer_id_)
  return _s;
}
inline const std::string& InStationRequest::_internal_stationer_id_() const {
  return _impl_.stationer_id__.Get();
}
inline void InStationRequest::_internal_set_stationer_id_(const std::string& value) {
  
  _impl_.stationer_id__.Set(value, GetArenaForAllocation());
}
inline std::string* InStationRequest::_internal_mutable_stationer_id_() {
  
  return _impl_.stationer_id__.Mutable(GetArenaForAllocation());
}
inline std::string* InStationRequest::release_stationer_id_() {
  // @@protoc_insertion_point(field_release:stationerspace.InStationRequest.stationer_id_)
  return _impl_.stationer_id__.Release();
}
inline void InStationRequest::set_allocated_stationer_id_(std::string* stationer_id_) {
  if (stationer_id_ != nullptr) {
    
  } else {
    
  }
  _impl_.stationer_id__.SetAllocated(stationer_id_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stationer_id__.IsDefault()) {
    _impl_.stationer_id__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:stationerspace.InStationRequest.stationer_id_)
}

// string order_id_ = 2;
inline void InStationRequest::clear_order_id_() {
  _impl_.order_id__.ClearToEmpty();
}
inline const std::string& InStationRequest::order_id_() const {
  // @@protoc_insertion_point(field_get:stationerspace.InStationRequest.order_id_)
  return _internal_order_id_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InStationRequest::set_order_id_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.order_id__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:stationerspace.InStationRequest.order_id_)
}
inline std::string* InStationRequest::mutable_order_id_() {
  std::string* _s = _internal_mutable_order_id_();
  // @@protoc_insertion_point(field_mutable:stationerspace.InStationRequest.order_id_)
  return _s;
}
inline const std::string& InStationRequest::_internal_order_id_() const {
  return _impl_.order_id__.Get();
}
inline void InStationRequest::_internal_set_order_id_(const std::string& value) {
  
  _impl_.order_id__.Set(value, GetArenaForAllocation());
}
inline std::string* InStationRequest::_internal_mutable_order_id_() {
  
  return _impl_.order_id__.Mutable(GetArenaForAllocation());
}
inline std::string* InStationRequest::release_order_id_() {
  // @@protoc_insertion_point(field_release:stationerspace.InStationRequest.order_id_)
  return _impl_.order_id__.Release();
}
inline void InStationRequest::set_allocated_order_id_(std::string* order_id_) {
  if (order_id_ != nullptr) {
    
  } else {
    
  }
  _impl_.order_id__.SetAllocated(order_id_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.order_id__.IsDefault()) {
    _impl_.order_id__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:stationerspace.InStationRequest.order_id_)
}

// string station_id_ = 3;
inline void InStationRequest::clear_station_id_() {
  _impl_.station_id__.ClearToEmpty();
}
inline const std::string& InStationRequest::station_id_() const {
  // @@protoc_insertion_point(field_get:stationerspace.InStationRequest.station_id_)
  return _internal_station_id_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InStationRequest::set_station_id_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.station_id__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:stationerspace.InStationRequest.station_id_)
}
inline std::string* InStationRequest::mutable_station_id_() {
  std::string* _s = _internal_mutable_station_id_();
  // @@protoc_insertion_point(field_mutable:stationerspace.InStationRequest.station_id_)
  return _s;
}
inline const std::string& InStationRequest::_internal_station_id_() const {
  return _impl_.station_id__.Get();
}
inline void InStationRequest::_internal_set_station_id_(const std::string& value) {
  
  _impl_.station_id__.Set(value, GetArenaForAllocation());
}
inline std::string* InStationRequest::_internal_mutable_station_id_() {
  
  return _impl_.station_id__.Mutable(GetArenaForAllocation());
}
inline std::string* InStationRequest::release_station_id_() {
  // @@protoc_insertion_point(field_release:stationerspace.InStationRequest.station_id_)
  return _impl_.station_id__.Release();
}
inline void InStationRequest::set_allocated_station_id_(std::string* station_id_) {
  if (station_id_ != nullptr) {
    
  } else {
    
  }
  _impl_.station_id__.SetAllocated(station_id_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.station_id__.IsDefault()) {
    _impl_.station_id__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:stationerspace.InStationRequest.station_id_)
}

// -------------------------------------------------------------------

// OutStationRequest

// string stationer_id_ = 1;
inline void OutStationRequest::clear_stationer_id_() {
  _impl_.stationer_id__.ClearToEmpty();
}
inline const std::string& OutStationRequest::stationer_id_() const {
  // @@protoc_insertion_point(field_get:stationerspace.OutStationRequest.stationer_id_)
  return _internal_stationer_id_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OutStationRequest::set_stationer_id_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.stationer_id__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:stationerspace.OutStationRequest.stationer_id_)
}
inline std::string* OutStationRequest::mutable_stationer_id_() {
  std::string* _s = _internal_mutable_stationer_id_();
  // @@protoc_insertion_point(field_mutable:stationerspace.OutStationRequest.stationer_id_)
  return _s;
}
inline const std::string& OutStationRequest::_internal_stationer_id_() const {
  return _impl_.stationer_id__.Get();
}
inline void OutStationRequest::_internal_set_stationer_id_(const std::string& value) {
  
  _impl_.stationer_id__.Set(value, GetArenaForAllocation());
}
inline std::string* OutStationRequest::_internal_mutable_stationer_id_() {
  
  return _impl_.stationer_id__.Mutable(GetArenaForAllocation());
}
inline std::string* OutStationRequest::release_stationer_id_() {
  // @@protoc_insertion_point(field_release:stationerspace.OutStationRequest.stationer_id_)
  return _impl_.stationer_id__.Release();
}
inline void OutStationRequest::set_allocated_stationer_id_(std::string* stationer_id_) {
  if (stationer_id_ != nullptr) {
    
  } else {
    
  }
  _impl_.stationer_id__.SetAllocated(stationer_id_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stationer_id__.IsDefault()) {
    _impl_.stationer_id__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:stationerspace.OutStationRequest.stationer_id_)
}

// string order_id_ = 2;
inline void OutStationRequest::clear_order_id_() {
  _impl_.order_id__.ClearToEmpty();
}
inline const std::string& OutStationRequest::order_id_() const {
  // @@protoc_insertion_point(field_get:stationerspace.OutStationRequest.order_id_)
  return _internal_order_id_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OutStationRequest::set_order_id_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.order_id__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:stationerspace.OutStationRequest.order_id_)
}
inline std::string* OutStationRequest::mutable_order_id_() {
  std::string* _s = _internal_mutable_order_id_();
  // @@protoc_insertion_point(field_mutable:stationerspace.OutStationRequest.order_id_)
  return _s;
}
inline const std::string& OutStationRequest::_internal_order_id_() const {
  return _impl_.order_id__.Get();
}
inline void OutStationRequest::_internal_set_order_id_(const std::string& value) {
  
  _impl_.order_id__.Set(value, GetArenaForAllocation());
}
inline std::string* OutStationRequest::_internal_mutable_order_id_() {
  
  return _impl_.order_id__.Mutable(GetArenaForAllocation());
}
inline std::string* OutStationRequest::release_order_id_() {
  // @@protoc_insertion_point(field_release:stationerspace.OutStationRequest.order_id_)
  return _impl_.order_id__.Release();
}
inline void OutStationRequest::set_allocated_order_id_(std::string* order_id_) {
  if (order_id_ != nullptr) {
    
  } else {
    
  }
  _impl_.order_id__.SetAllocated(order_id_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.order_id__.IsDefault()) {
    _impl_.order_id__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:stationerspace.OutStationRequest.order_id_)
}

// string station_id_ = 3;
inline void OutStationRequest::clear_station_id_() {
  _impl_.station_id__.ClearToEmpty();
}
inline const std::string& OutStationRequest::station_id_() const {
  // @@protoc_insertion_point(field_get:stationerspace.OutStationRequest.station_id_)
  return _internal_station_id_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OutStationRequest::set_station_id_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.station_id__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:stationerspace.OutStationRequest.station_id_)
}
inline std::string* OutStationRequest::mutable_station_id_() {
  std::string* _s = _internal_mutable_station_id_();
  // @@protoc_insertion_point(field_mutable:stationerspace.OutStationRequest.station_id_)
  return _s;
}
inline const std::string& OutStationRequest::_internal_station_id_() const {
  return _impl_.station_id__.Get();
}
inline void OutStationRequest::_internal_set_station_id_(const std::string& value) {
  
  _impl_.station_id__.Set(value, GetArenaForAllocation());
}
inline std::string* OutStationRequest::_internal_mutable_station_id_() {
  
  return _impl_.station_id__.Mutable(GetArenaForAllocation());
}
inline std::string* OutStationRequest::release_station_id_() {
  // @@protoc_insertion_point(field_release:stationerspace.OutStationRequest.station_id_)
  return _impl_.station_id__.Release();
}
inline void OutStationRequest::set_allocated_station_id_(std::string* station_id_) {
  if (station_id_ != nullptr) {
    
  } else {
    
  }
  _impl_.station_id__.SetAllocated(station_id_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.station_id__.IsDefault()) {
    _impl_.station_id__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:stationerspace.OutStationRequest.station_id_)
}

// string next_address_ = 4;
inline void OutStationRequest::clear_next_address_() {
  _impl_.next_address__.ClearToEmpty();
}
inline const std::string& OutStationRequest::next_address_() const {
  // @@protoc_insertion_point(field_get:stationerspace.OutStationRequest.next_address_)
  return _internal_next_address_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OutStationRequest::set_next_address_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.next_address__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:stationerspace.OutStationRequest.next_address_)
}
inline std::string* OutStationRequest::mutable_next_address_() {
  std::string* _s = _internal_mutable_next_address_();
  // @@protoc_insertion_point(field_mutable:stationerspace.OutStationRequest.next_address_)
  return _s;
}
inline const std::string& OutStationRequest::_internal_next_address_() const {
  return _impl_.next_address__.Get();
}
inline void OutStationRequest::_internal_set_next_address_(const std::string& value) {
  
  _impl_.next_address__.Set(value, GetArenaForAllocation());
}
inline std::string* OutStationRequest::_internal_mutable_next_address_() {
  
  return _impl_.next_address__.Mutable(GetArenaForAllocation());
}
inline std::string* OutStationRequest::release_next_address_() {
  // @@protoc_insertion_point(field_release:stationerspace.OutStationRequest.next_address_)
  return _impl_.next_address__.Release();
}
inline void OutStationRequest::set_allocated_next_address_(std::string* next_address_) {
  if (next_address_ != nullptr) {
    
  } else {
    
  }
  _impl_.next_address__.SetAllocated(next_address_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.next_address__.IsDefault()) {
    _impl_.next_address__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:stationerspace.OutStationRequest.next_address_)
}

// -------------------------------------------------------------------

// StationerInfo

// bool return_result_ = 1;
inline void StationerInfo::clear_return_result_() {
  _impl_.return_result__ = false;
}
inline bool StationerInfo::_internal_return_result_() const {
  return _impl_.return_result__;
}
inline bool StationerInfo::return_result_() const {
  // @@protoc_insertion_point(field_get:stationerspace.StationerInfo.return_result_)
  return _internal_return_result_();
}
inline void StationerInfo::_internal_set_return_result_(bool value) {
  
  _impl_.return_result__ = value;
}
inline void StationerInfo::set_return_result_(bool value) {
  _internal_set_return_result_(value);
  // @@protoc_insertion_point(field_set:stationerspace.StationerInfo.return_result_)
}

// string return_message_ = 2;
inline void StationerInfo::clear_return_message_() {
  _impl_.return_message__.ClearToEmpty();
}
inline const std::string& StationerInfo::return_message_() const {
  // @@protoc_insertion_point(field_get:stationerspace.StationerInfo.return_message_)
  return _internal_return_message_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StationerInfo::set_return_message_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.return_message__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:stationerspace.StationerInfo.return_message_)
}
inline std::string* StationerInfo::mutable_return_message_() {
  std::string* _s = _internal_mutable_return_message_();
  // @@protoc_insertion_point(field_mutable:stationerspace.StationerInfo.return_message_)
  return _s;
}
inline const std::string& StationerInfo::_internal_return_message_() const {
  return _impl_.return_message__.Get();
}
inline void StationerInfo::_internal_set_return_message_(const std::string& value) {
  
  _impl_.return_message__.Set(value, GetArenaForAllocation());
}
inline std::string* StationerInfo::_internal_mutable_return_message_() {
  
  return _impl_.return_message__.Mutable(GetArenaForAllocation());
}
inline std::string* StationerInfo::release_return_message_() {
  // @@protoc_insertion_point(field_release:stationerspace.StationerInfo.return_message_)
  return _impl_.return_message__.Release();
}
inline void StationerInfo::set_allocated_return_message_(std::string* return_message_) {
  if (return_message_ != nullptr) {
    
  } else {
    
  }
  _impl_.return_message__.SetAllocated(return_message_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.return_message__.IsDefault()) {
    _impl_.return_message__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:stationerspace.StationerInfo.return_message_)
}

// string stationer_id_ = 3;
inline void StationerInfo::clear_stationer_id_() {
  _impl_.stationer_id__.ClearToEmpty();
}
inline const std::string& StationerInfo::stationer_id_() const {
  // @@protoc_insertion_point(field_get:stationerspace.StationerInfo.stationer_id_)
  return _internal_stationer_id_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StationerInfo::set_stationer_id_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.stationer_id__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:stationerspace.StationerInfo.stationer_id_)
}
inline std::string* StationerInfo::mutable_stationer_id_() {
  std::string* _s = _internal_mutable_stationer_id_();
  // @@protoc_insertion_point(field_mutable:stationerspace.StationerInfo.stationer_id_)
  return _s;
}
inline const std::string& StationerInfo::_internal_stationer_id_() const {
  return _impl_.stationer_id__.Get();
}
inline void StationerInfo::_internal_set_stationer_id_(const std::string& value) {
  
  _impl_.stationer_id__.Set(value, GetArenaForAllocation());
}
inline std::string* StationerInfo::_internal_mutable_stationer_id_() {
  
  return _impl_.stationer_id__.Mutable(GetArenaForAllocation());
}
inline std::string* StationerInfo::release_stationer_id_() {
  // @@protoc_insertion_point(field_release:stationerspace.StationerInfo.stationer_id_)
  return _impl_.stationer_id__.Release();
}
inline void StationerInfo::set_allocated_stationer_id_(std::string* stationer_id_) {
  if (stationer_id_ != nullptr) {
    
  } else {
    
  }
  _impl_.stationer_id__.SetAllocated(stationer_id_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stationer_id__.IsDefault()) {
    _impl_.stationer_id__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:stationerspace.StationerInfo.stationer_id_)
}

// string station_id_ = 4;
inline void StationerInfo::clear_station_id_() {
  _impl_.station_id__.ClearToEmpty();
}
inline const std::string& StationerInfo::station_id_() const {
  // @@protoc_insertion_point(field_get:stationerspace.StationerInfo.station_id_)
  return _internal_station_id_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StationerInfo::set_station_id_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.station_id__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:stationerspace.StationerInfo.station_id_)
}
inline std::string* StationerInfo::mutable_station_id_() {
  std::string* _s = _internal_mutable_station_id_();
  // @@protoc_insertion_point(field_mutable:stationerspace.StationerInfo.station_id_)
  return _s;
}
inline const std::string& StationerInfo::_internal_station_id_() const {
  return _impl_.station_id__.Get();
}
inline void StationerInfo::_internal_set_station_id_(const std::string& value) {
  
  _impl_.station_id__.Set(value, GetArenaForAllocation());
}
inline std::string* StationerInfo::_internal_mutable_station_id_() {
  
  return _impl_.station_id__.Mutable(GetArenaForAllocation());
}
inline std::string* StationerInfo::release_station_id_() {
  // @@protoc_insertion_point(field_release:stationerspace.StationerInfo.station_id_)
  return _impl_.station_id__.Release();
}
inline void StationerInfo::set_allocated_station_id_(std::string* station_id_) {
  if (station_id_ != nullptr) {
    
  } else {
    
  }
  _impl_.station_id__.SetAllocated(station_id_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.station_id__.IsDefault()) {
    _impl_.station_id__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:stationerspace.StationerInfo.station_id_)
}

// string stationer_name = 5;
inline void StationerInfo::clear_stationer_name() {
  _impl_.stationer_name_.ClearToEmpty();
}
inline const std::string& StationerInfo::stationer_name() const {
  // @@protoc_insertion_point(field_get:stationerspace.StationerInfo.stationer_name)
  return _internal_stationer_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StationerInfo::set_stationer_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.stationer_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:stationerspace.StationerInfo.stationer_name)
}
inline std::string* StationerInfo::mutable_stationer_name() {
  std::string* _s = _internal_mutable_stationer_name();
  // @@protoc_insertion_point(field_mutable:stationerspace.StationerInfo.stationer_name)
  return _s;
}
inline const std::string& StationerInfo::_internal_stationer_name() const {
  return _impl_.stationer_name_.Get();
}
inline void StationerInfo::_internal_set_stationer_name(const std::string& value) {
  
  _impl_.stationer_name_.Set(value, GetArenaForAllocation());
}
inline std::string* StationerInfo::_internal_mutable_stationer_name() {
  
  return _impl_.stationer_name_.Mutable(GetArenaForAllocation());
}
inline std::string* StationerInfo::release_stationer_name() {
  // @@protoc_insertion_point(field_release:stationerspace.StationerInfo.stationer_name)
  return _impl_.stationer_name_.Release();
}
inline void StationerInfo::set_allocated_stationer_name(std::string* stationer_name) {
  if (stationer_name != nullptr) {
    
  } else {
    
  }
  _impl_.stationer_name_.SetAllocated(stationer_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stationer_name_.IsDefault()) {
    _impl_.stationer_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:stationerspace.StationerInfo.stationer_name)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace stationerspace

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_mystationer_2eproto
